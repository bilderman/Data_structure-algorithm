---
	
---

## 1.线性表

### 1.1并集

```c++
unionL(*L1,L2)
{
  int length1,length2,i;
  ElementType e;
  length1=ListLength(L1);
  length2=ListLength(L2);
  for(int i=1;i<=length2;i++)
  {
     GetElem(L2,i,&e);
       if( !LocateElem(*L1,e))
	{
	  ListInsert(*L1,++length1,e);
	}		
  }
}
```

### 1.2插入线性表元素

```c+
//时间复杂度O(n)
//线性表从一开始，数组从零开始
Typedef OK true;
Typedef error false;
Status ListInsert(SqList *L , int i , ElementType e)
{
    if(L->length==MAXSIZE)
    {
    	return error;
	}
	if(i<1||i>L->length+1)
	{
    	return error;
	}
	if(i>=1&&i<=L->length)//在线性表之内,不是队尾
	{
		for(int k=L->length-1;k>=i-1;k--)
		L.data[k+1]=L.data[k];
	}
	L[i-1]=e;
	L->length++;
	
	return OK;
}
```



### 1.3删除线性表元素

```c+
//时间复杂度O(n)
Status ListDelete(SqList *L,int i,ElementType *e)
{
	if(L->length==MINSIZE)
	{
		return ERROR;
	}
	if(i<1||i>L->length+1)
	{
		return ERROR;
	}
	*e=L->data[i-1];//相当于回收站，储存删除的元素
	if(i<L->length)
	{
		for(int k=i;k<=L->length;k++)
		{
			L->data[k-1]=L->data[k];
		}
	}
	
	L->length--;
	return OK;
}
```

### 1.4单链表定义

头指针---头结点【数据域（一般放长度）|指针域】---第一个数据结点【数据域|指针域】········



***如果定义如下：***
***A *p则使用：p->play(); 左边是结构指针。***
***A p 则使用：p.paly(); 左边是结构变量。***
***总结：***
***箭头（->）：左边必须为指针；***
***点号（.）：左边必须为实体。***

```c++
typedef struct Node
{
    ElemType data;//数据域
    struct Node *next;    
}Node;
typedef struct Node* LinkList;
```

### 1.5单链表查找元素

```c++
//时间复杂度O(n)
Status GetElem(LinkList L,int i,EleType *e)
{
    LinkList p;//指向头结点的 头指针
    p=L->next;//p为第一个数据结点
    int j=1;
    
    while(p && j<i)
    {
        p=p->next;
        j++;
    }
    if(!p||j>i)
    {
        return ERROR;
    }
    
    *e=p->data;
    return OK;
}
```

### 1.6头插法建立单链表//数据顺序相反

```
//*L为头结点
void CreateListHead(LinkList *L,int n)//L为双指针，用于给实参地址传递，不用返回值,相当于头指针
{
	LinkList p;
	srand(time(0));
	
	*L=(LinkList)malloc(sizeof(Node));//配所需的内存空间,并返回一个指向它的指针。
	(*L)->next=NULL;//*的优先级不高
	
	for(int i=0;i<n;i++)
	{
		p=(LinkList)malloc(sizeof(Node));
		p->data=rand()%100+1;
		p->next=(*L)->next;
		(*L)->next=p;
	}
}
```

### 1.7尾插法建立单链表

```c++
void CreateListTail(LinkList *L,int n)//L为双指针，用于给实参地址传递，不用返回值相当于头指针
{
	LinkList p,r;
	srand(time(0));
	
	*L=(LinkList)malloc(sizeof(Node));//配所需的内存空间,并返回一个指向它的指针。
	r=*L
	
	for(int i=0;i<n;i++)
	{
		p=(LinkList)malloc(sizeof(Node));
		p->data=rand()%100+1;
		r->next=p;
		r=p;
	}
    r->next=NULL;
}
```

### 1.8单链表的整表删除

```c
void ClearList(LinkList *L)
{
    LinkList p,q;
    p=(*L);
    
    while(p)
    {
        q=p->next;
        free(p);
        p=q;
    }
    
    (*L)->next=NULL;
    return OK;
}
```

### 1.9单链表例题--寻找中间单链表节点数据//包括头结点

```c
Status GetMidNode(LinkList L,ElemType *e)
{
    LinkList search,mid;
    search=mid=L;
    while(search->next!=NULL)
    {
        if(search->next->next!=NULL)
        {
            search=search->next->next;
            mid=mid->next;
        }
        else
        {
            search=search->next;
        }
    }
    *e=mid->data;
    return OK;
}
```

## 2.静态链表

用数组描述的链表，即称为静态链表。
在C语言中，静态链表的表现形式即为结构体数组，结构体变量包括数据域data和游标CUR。

下标为零的游标是第一个备用列表的下标，下标为MAXSIZE-1的游标是第一个非空数据的下标，最后一个非零元素的游标是零。(0的游标cur-第一个空元素下标，999-第一个有元素下标，最后一个有元素-0)

### 2.1静态链表定义（线性表的静态链表存储结构）

```c
#define MAXSIZE 1000
typedef struct
{
    ElemType data;
    int cur;//游标cursor
}Component,StaticLinkList[MAXSIZE];
```



### 2.2静态链表初始化

```c
Status InitList(StaticLinkList space)
{
    int i;
	for(i=0;i<MAXSIZE-1;i++)
        space[i].cur=i+1;
    space[MAXSIZE-1].cur=0;
    return OK;
}
```

### 2.2静态链表插入元素--获得空闲分量的下标

```c
Status Malloc_SLL(StaticLinkList space)
{
    int i=space[0].cur;
    if(space[0].cur)//静态链表还有备用链表
        space[0].cur=space[i].cur;
    //把他的下一个分量作为备用
    return i;
}
```

游标	5	2	3	4	0	6	7	...	1

数据		  A	C	D   E		    	 ...

下标	0	1	2	3	4	5	6	...	999

### 2.3静态链表插入元素

```c
Status InsertList(StaticLinkList L,int i,EleType e)
{
    int j,k,l;
    
    k=MAXSIZE-1;
    if(i<1||i>ListLength(L)+1)
    {
        return ERROR;
    }   
    j=Malloc_SLL(L);//空闲分量的下标
    if(j)//静态链表还有备用链表
    {
        L[j].data=e;
        for(l=1;l<=i-1;l++)
        {
            k=L[k].cur;
        }
        L[j].cur=L[k].cur;
        L[k].cur=j;
            
        return OK;        
    }
    return ERROR;
}
```

2.4静态链表删除元素(最后一个元素)

```c
Status DeleteList(StaticLinkList L,int i)
{
    int j,k;
    if(i<1||i>ListLength(L))
    {
        return ERROR;
    }
    k=MAXSIZE-1;
    
    for(j=1;j<=i-1;j++)
    {
        k=L[k].cur;
    }
    
    j=L[k].cur;
    L[k].cur=L[j].cur;
    Free_SLL(L,j);
    return OK;
}

void Free_SLL(StaticLinkList space,int i)
{
    space[i].cur=space[0].cur;
    space[0].cur=i;
}

int ListLength(StaticLinkList L)
{
    int j=0;
    int k=L[MAXSIZE-1].cur;
    while(k)
    {
        k=L[k].cur;
        j++;
    }
    rerutn j;
}
```

## 3.循环链表

循环链表不一定有头结点

### 3.1循环链表定义

```c
typedef struct CLinkList
{
    int data;
    struct CLinkList* node;
}node;
```

### 3.2循环链表初始化

```c
void ds_init(node **pNode)
{
    int item;
    node *temp;
    node *target;
    
    ptintf("请输入节点的值");
    
    while(1)
    {
        scanf("%d",&item);
        fflush(stdin);//刷新缓存
        if(item==0)
            return;
        if((*pNode)==NULL)
        {
            *pNode=(node*)malloc(sizeof(struct cLinkList));
            if(!(*pNode))
            	exit(0);
            *pNode->data=item;
            *pNode->next=*pNode;//使之循环
        }
        else
        {
            for(target=*pNode;target->next!=*pNode;target=target->next)
                ;
            temp=(node*)malloc(sizeof(struct cLinkList));
            if(!temp)
            	exit(0);
            temp->data=item;
            temp->next=*pNode;
            target->next=temp;
        }
    }
}
```

### 3.3循环链表插入

```c
void ds_insert(node **pNode,int i)
{
    int item;
    node *temp;
    node *target;
    node *p;
    
    ptintf("请输入节点的值");
    scanf("%d",&item);
    
    if(i==1)//插入第一个节点
    {
        *temp=(node*)malloc(sizeof(struct cLinkList));
        if(!temp)
        exit(0);
        
        temp->data=item;
        for(target=*pNode;target->next!=*pNode;target=target->next)
                ;
        target->next=temp;
        temp->next=*pNode;
        *pNode=temp;////////////////注意
    }
    else
    {
        target=*pNode;
        for(int j=1;j<(i-1);j++)
        {
            target=target->next;
        }
        
        *temp=(node*)malloc(sizeof(struct cLinkList));//开辟内存空间了才能存储数据
        if(!temp)
        	exit(0);
        temp->data=item;
        p=target->next;
        
        target->next=temp;
        temp->next=p;
    }
}
```

### 3.4循环链表删除

```c
void ds_insert(node **pNode,int i)
{
    node *temp;
    node *target;
    node *p;
    
    if(i==1)//删除第一个节点
    {       
        for(target=*pNode;target->next!=*pNode;target=target->next)
                ;
        temp=*pNode;//做释放用的
        *pNode=(*pNode)->next;
        target->next=*pNode;
        free(temp);
    }
    else
    {
        target=*pNode;
        for(int j=1;j<(i-1);j++)
        {
            target=target->next;
        }        
        temp=target->next;//做释放用的
        target->next=temp->next;
        free(temp);
    }
}
```

### 3.5循环链表查找

```c
int ds_search(node *pNode,int elem)
{
    node *target;
    int i=1;
    for(target=*pNode;target->data!=elem&&target->next!=*pNode;target=target->next)
    {
        target=target->next;
    }
    if(target->data!=data)
    	return 0;
    else
        return i;
}
```

3.6魔术师问题

```c
//初始化
LinkList CreateLinkList()
{
    LinkList head=NULL;
    LinkList r,s;
    int i;
    
    r=head;
    for(i=1;i<=CardNumber;i++)
    {
        s=(LinkList)malloc(sizeof(sqList));
        s->data=0;
        if(head==NULL)
            head=s;
        else
            r->next=s;
        r=s;
    }
    r->next=head;
    return head;
}

//发牌顺序计算
void Magician(LinkList head)
{
    LinkList p;
    int j;
    int Countnumber=2;
    
    p=head;
    p->data=1;//第一张牌放一
    while(1)
    {
        for(j=0;j<Countnumber;j++)
        {
            p=p->next;
            if(p->data!=0)//有牌下一个位置
            {
                //p=p->next;
                j--;
            }
        }
        if(p->data==0)
        {
            p->data=Countnumber;
            Countnumber++; 
            if(Countnumber==14)
                break;
        }
    }
}

//销毁
void DestroyList(LinkList* list)
{
    
}

int main()
{
    LinkList p;
    p=CreateLinkList();
    Magician(p);
    printf("顺序依次是");
    for(int i=0;i<Countnumber;i++)
    {
        printf("黑桃%d",p->data);
        p=p->next;
    }
    DestroyList(&p);
    return 0;	
}
```

## 4.双向链表

```c
typedef struct DualNode
{
    ElemType data;
    struct DualNode *prior;
    struct DualNode *next;    
}DualNode,* DuLinkList;
```

### 4.1双向链表的插入操作

[  |  |  ]				[  |  |  ]p

  			[  |  |  ]s

```c
s->next=p;
s->prior=p->prior;
p->prior->next=s;
p->prior=s;
```

### 4.2双向链表的删除操作

[  |  |  ]	[  |  |  ]p   [  |  |  ]

```c
p->prior->next=p->next;
p->next->prior=p->prior;
free(p);
```

### 4.3双向循环链表实践

按要求输出26个英文字母

```c
#include "malloc.h"
#include<stdio.h>
#include <iostream>
using namespace std;

#define OK 1;
#define ERROR 0;
typedef char ElemType;
typedef int status;
//节点
typedef struct DualNode
{
    ElemType data;
    struct DualNode* prior;
    struct DualNode* next;
}DualNode,* DuLinkList;

//建立链表
status InitDuLinkList(DuLinkList * L)//尾插法
{
    DuLinkList p,q;

    *L=(DuLinkList)malloc(sizeof(DualNode));//头节点没有数据
    if (!(*L))
        return ERROR;
    (*L)->next = NULL;
    (*L)->prior = NULL;
    p = (*L);

    for (int i = 0; i < 26; i++)
    {
        q=(DuLinkList)malloc(sizeof(DualNode));
        if (!q)
            return ERROR;
        q->data = 'A' +i;
        q->prior = p;
        q->next = p->next;
        p->next = q;

        p = q;
    }
    p->next = (*L)->next;//不要忘
    (*L)->next->prior = p;
    return OK;
}
void Ceasar(DuLinkList* L,int n)//(*L)初始节点位置
{
    if (n > 0)
    {
        do
        {
            (*L) = (*L)->next;
        } while (n--);
    }
    if (n < 0)
    {
        (*L) = (*L)->next;//有头结点
        do
        {
            (*L) = (*L)->prior;
        } while (++n);
    }
}
int main()
{
    int n;
    printf("请输入一个整数\n");
    cin >> n;

    DuLinkList p;
    InitDuLinkList(&p);
    Ceasar(&p, n);
    for(int i=0;i<26;i++)
    {
        printf("%c ", p->data);
        p = p->next;
    }   
    return 0;
}
```

## 5.栈

### 5.1栈的顺序存储结构

```c
typedef struct
{
    ElemType *base;
    ElemType *top;
    int stackSize;//栈的最大容量，占据内存空间的大小
}sqStack;
```

### 5.2创建一个栈

```c
#define STACK_INIT_SIZE 100
initSttack(sqStack *s)
{
    s->base=(ElemType *)malloc(STACK_INIT_SIZE*sizeof(ElemType));////ElemType *和base，top形式统一
    if(!s->base)
        exit(0);
    s->top=s->base;//最开始，栈顶就是栈底
    s->stackSize=STACK_INIT_SIZE;
}
```

### 5.3入栈操作

```c
#define STACKINCREMENT 10

Push(sqStack *s,ElemType e)
{
    //如果栈满，追加空间
    if(s->top-s->base>=s->stackSize)
    {
        s->base=(ElemType*)realloc(s->base,(s->stackSize+STACKINCREMENT)
                                   *sizeof(ElemType));//realloc扩展开辟内存
        if(!s->base)
            exit(0);
        s->top=s->base+s->stackSize;
        s->stackSize=s->stackSize+STACKINCREMENT;        
    }
    *(s->top)=e;
    s->top++;
}
```

### 5.4出栈操作

```c
Pop(sqStack *s,ElemType *e)
{
    if(s->top==s->base)//空栈
        return;
    *e=*--(s->top);
}
```

### 5.5销毁一个栈

```c
DestroyStack(sqStack *s)
{
    int len,i;
    len=s->stackSize;
    for(i=0;i<len;i++)
    {
        free(s->base);
        s->base++;
    }
    s->base=s->top=NULL
    s->stackSize=0;
}
```

### 5.6栈的当前容量

```c
int StackLen(sqStack s)
{
    return (s.top-s.base);//栈的最大容量，占据内存空间的大小
}
```

### 5.7示例--二进制转化为十进制

```c
#include<stdio.h>
#include<iostream>
#include<stdlib.h>//包含malloc
using namespace std;

#define STACK_INIT_SIZE 20
#define STACK_INCREMENT 10
typedef char ElemType;
typedef struct
{
	ElemType* base;
	ElemType* top;
	int stack_size;
}sqStack;

void initstack(sqStack* s)
{
	s->base = (ElemType*)malloc(STACK_INIT_SIZE * sizeof(ElemType));
	if (!s->base)
		exit(0);
	s->top = s->base;
	s->stack_size = STACK_INIT_SIZE;
}

void push(sqStack* s, ElemType e)
{
	if (s->top - s->base >= s->stack_size)
	{
		s->base = (ElemType*)realloc(s->base, (s->stack_size + STACK_INCREMENT) * sizeof(ElemType));
		if (!s->base)
			exit(0);
		s->top = s->base + STACK_INCREMENT;
		s->stack_size = s->stack_size + s->stack_Size;
	}
	*(s->top) = e;
	s->top++;
}

void pop(sqStack* s, ElemType* e)
{
	if (s->top == s->base)
		return;
	*e = *(--s->top);
}

int stack_len(sqStack *s)
{
	return (s->top - s->base);
}

void main()
{
	int len,sum=0;
	ElemType c;
	sqStack s;
	initstack(&s);

	cout << "输入一个二进制数，以#作为结尾" << endl;
	cin >> c;
	while (c != '#')
	{
		push(&s, c);
		cin >> c;
	}
	getchar();//吃掉一个"\n"

	len = stack_len(&s);
	for (int i = 0; i < len; i++)
	{
		pop(&s, &c);
		sum += (c - 48) * pow(2, i);
	}
	cout << "转化为十进制是" << sum;
}
```

### 5.7逆波兰表达式

a+b--->a b +

a+(b+c)--->a b c - +

a+(b-c)*d--->a b c - d * +

a+d*(b-c)--->a d b c - * +

```c
//输出一直为零，失败//

#include<stdio.h>
#include<ctype.h>//isdigit
#include<iostream>
#include<stdlib.h>//包含malloc,atof字符串转浮点型
using namespace std;

#define STACK_INIT_SIZE 20
#define STACK_INCREMENT 10
#define MAXBUFFER 10//输入缓存
typedef double ElemType;

typedef struct
{
	ElemType*base;
	ElemType* top;
	int stack_size;
}sqStack;

void initstack(sqStack* s)
{
	s->base = (ElemType*)malloc(STACK_INIT_SIZE * sizeof(ElemType));
	if (!s->base)
		exit(0);
	s->top = s->base;
	s->stack_size = STACK_INIT_SIZE;
}

void push(sqStack* s, ElemType e)
{
	if (s->top - s->base >= s->stack_size)
	{
		s->base = (ElemType*)realloc(s->base, (s->stack_size + STACK_INCREMENT) * sizeof(ElemType));
		if (!s->base)
			exit(0);
		s->top = s->base + s->stack_size;
		s->stack_size = s->stack_size + STACK_INCREMENT;
	}
	*(s->top) = e;
	s->top++;
}

void pop(sqStack* s, ElemType* e)
{
	if (s->top == s->base)
		return;
	*e = *(--s->top);
}

int stack_len(sqStack *s)
{
	return (s->top - s->base);
}
//1 2 - 4 5 + *
int  main()
{
	sqStack s;
	char c;//输入
	double d, e, result=0;
	int i = 0;
	char str[MAXBUFFER];

	initstack(&s);
	cout << "请按逆波兰表达式输入待计算数据，用空格隔开，用#结束" << endl;
	cin >> c;
	while (c != '#')
	{
		while (isdigit(c) || c == '.')//用于过滤数字
		{
			str[i++] = c;
			str[i] = '\0';///??
			if (i >= 10)
			{
				cout << "输入的数字位数过大"<<endl;
				return -1;
			}
			cin >> c;
			if (c == ' ')
			{
				d = atof(str);//字符串转浮点型
				push(&s, d);
				i = 0;
				break;
			}
		}

		switch (c)
		{
		case '+':
			pop(&s, &e);
			pop(&s, &d);
			push(&s, d + e);
			break;
		case '-':
			pop(&s, &e);
			pop(&s, &d);
			push(&s, d - e);
			break;
		case '*':
			pop(&s, &e);
			pop(&s, &d);
			push(&s, d * e);
			break;
		case '/':
			if (e == 0)
			{
				cout << "错误：除数为零";
				return -1;
			}
			pop(&s, &e);
			pop(&s, &d);
			push(&s, d / e);
			break;
		default:
			break;
		}	
		cin >> c;
	}
	pop(&s, &result);
	cout << "最终结果为" << result << endl;

	return 0;
}
```

### 5.8中缀表达式转化为后缀表达式

```c
//错了

//(1-2)*(4+5)---->1 2 - 4 5 + *
//1+(2-3)*4+10/5---->1 2 3 - 4 * + 10 5 / +
#include<stdio.h>
#include<ctype.h>//isdigit
#include<iostream>
#include<stdlib.h>//包含malloc,atof字符串转浮点型
using namespace std;

#define STACK_INIT_SIZE 20
#define STACK_INCREMENT 10
#define MAXBUFFER 10//输入缓存
typedef char ElemType;

typedef struct
{
	ElemType*base;
	ElemType* top;
	int stack_size;
}sqStack;

void initstack(sqStack* s)
{
	s->base = (ElemType*)malloc(STACK_INIT_SIZE * sizeof(ElemType));
	if (!s->base)
		exit(0);
	s->top = s->base;
	s->stack_size = STACK_INIT_SIZE;
}

void push(sqStack* s, ElemType e)
{
	if (s->top - s->base >= s->stack_size)
	{
		s->base = (ElemType*)realloc(s->base, (s->stack_size + STACK_INCREMENT) * sizeof(ElemType));
		if (!s->base)
			exit(0);
		s->top = s->base + s->stack_size;
		s->stack_size = s->stack_size + STACK_INCREMENT;
	}
	*(s->top) = e;
	s->top++;
}

void pop(sqStack* s, ElemType* e)
{
	if (s->top == s->base)
		return;
	*e = *(--s->top);
}

int stack_len(sqStack *s)
{
	return (s->top - s->base);
}
//1 2 - 4 5 + *
int  main()
{
	sqStack s;
	char c, e;

	initstack(&s);
	cout << "请输入中缀表达式，用#结束" << endl;
	cin >> c;
	while (c != '#')
	{
		if (c >= '0' && c <= '9')//数字直接输出
		{
			cout << c ;
			cin >> c;
			if (c < '0' && c > '9')
			{
				cout << ' ';
			}
		}
		else if (')' == c)//等号判断常量放左边便于检查少打一个等号
		{
			pop(&s, &e);
			while ('（' != e)//一直弹出知道匹配到左括号
			{
				cout << e << ' ';
				pop(&s, &e);
			}
		}
		else if('+'==c||'-'==c)//判断栈顶符号的优先级和刚输入的谁高
		{
			if (!stack_len(&s))
			{
				push(&s, c);
			}
			else
			{
				do
				{
					pop(&s, &e);
					if ('(' == e)//匹配（
					{
						push(&s, e);
					}
					else
					{
						cout << e << ' ';//先进去的+或-输出
					}
				} while (stack_len(&s)&&'('!=e);
				push(&s, c);//压入刚输入的+或-
			}
		}
		else if('(' == c|| '*' == c|| '/' == c)//高优先级直接进去
		{
			push(&s, c);
		}
		else if ('#' == c)
		{
			break;
		}
		else
		{
			cout << "输入格式错误" << endl;
			return -1;
		}
		cin >> c;
	}
	while (stack_len(&s))
	{
		pop(&s, &e);
		cout << e<<' ';
	}
	return 0;
}
```

## 6.栈的链式存储结构

### 6.1定义

top指针->[data|next]->[data|next]->···->[  |^]   栈链示意图(从右往左的插入顺序，第一个为空)

​          栈顶                                               栈底

```c
typedef struct StackNode
{
	Elemtype data;//存放栈的数据
	struct StackNode *next;
}StackNode,*LinkStackPtr;

typedef struct LinkStack
{
    LinkStackPtr top;//top指针
    int count;//栈元素计数器
}
```

### 6.2进栈操作(从右往左)

```c
Status Push(LinkStack *s,Elemtype e)
{
    LinkStackPtr p=(LinkStackPtr)malloc(sizeof(StackNode));
    p->data=e;
    p->next=s->top;
    s->top=p;
    s->count++;
    return OK;
}
```

### 6.3出栈操作

```c
Status Pop(LinkStack *s,Elemtype *e)
{
    LinkStackPtr p;
    if(StackEmpty(*s))//是否为空栈
        return ERROR;
    *e=s->top->data;
    p=s->top;
    s->top=s->top->next;
    free(p);
    s->count--;
    return OK;
}
```

## 7.队列

### 7.1定义

队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表；(栈是后进先出的线性表)，二者都需要线性表或链表作为基础。

**栈通常是顺序表来实现，队列一般需要链表来实现。**

### 7.2链队列



```c
typedef struct QNode
{
    ElemType data;
    struct QNode *next;
}QNode,*QueuePtr;

typedef struct
{
    QueuePtr front,rear;//队头尾指针,头结点不必要
}LinkQueue;
```

[头结点|  ]--->[A1|  ]--->[A2|  ]--->···--->[An|^]

front                                                            rear

### 7.3创建一个队列//自己写的

```c
initQueue(LinkQueue *q)
{
    q->front=q->rear=(QueuePtr)malloc(sizeof(QNode));
    if(!q->front)
        exit(0);
    q->front->next=NULL;
}
```

### 7.4入队列操作(从后端入)

```c
InsertQueue(LinkQueue *q,ElemType e)
{
    p=(QueuePtr)malloc(sizeof(QNode));
    if(!p)
        exit(0);
    p->data=e;
    p->next=NULL;
    q->rear->next=p;
    q->rear=p;
    //free(p);
}
```

### 7.5出队列操作(从前端出)

```c
DeleteQueue(LinkQueue *q,ElemType *e)
{
    QueuePtr p;
    if(q->front==q->rear)
    	return;
    p=q->front->next;
    *e=p->data;
    q->front->next=p->next;
    if(q->rear==p)//注意
    	q->rear=q->front;
    free(p);
}
```

### 7.6销毁一个队列

```c
DestroyQueue(LinkQueue *q)
{
    while(q->front)
    {
        q->rear=q->front->next;
        free(q->front)
        q->front=q->rear;
    }
}
```

### 7.7定义循环队列

```c
#define MAXSIZE 100
typedef struct
{
    ElemType *base;//用于存放内存分配基地址，这里也可以用数组存放
    int front;
    int rear;
}cycleQueue;
```

### 7.8创建一个循环队列

[front,rear|   |   |   ]

```c
initcycleQueue(cycleQueue *q)
{
    q->base=(ElemType *)malloc(MAXSIZE*sizeof(ElemType));
    q->front=q->rear=0;
}
```



### 7.9循环队列入队列操作

```c
InsertcycleQueue(cycleQueue *q,ElemType e)
{
    if((q->rear+1)%MAXSIZE==q->front)
        return;//队列已满，最后一个内存不用，防止初始判断失误
    q->base[q->rear]=e;
    q->rear=(q->rear+1)%MAXSIZE;
}
```

### 7.10循环队列出队列操作

```c
DeleteQueue(cycleQueue *q,ElemType *e)
{
    if(q->front==q->rear)
        return;
    *e=q->base[front];
    q->front=(q->front+1)%MAXSIZE;
}
```

## 8.递归调用(for语句是迭代)

### 8.1递归反序输出字符串

```c++
#include<stdio.h>
#include<iostream>
using namespace std;
void print()
{
	char c;
	cin >> c;
	if (c != '#') print();
	if (c != '#') cout<<c;
}
int main()
{
	print();
	return 0;
}
```

### 8.2汉诺塔

问题一：将X上的63个盘子借助Z移到Y上；

将最底下的第64个盘子从X到Z；

问题二：将Y上的63个盘子借助X移到Z上。



问题一的圆盘移动步骤为：

-将X上的62个盘子借助Y移动到Z上；

-将最底下的第63个盘子从X到Y；

-将Z上的62个盘子借助X移到Y上。

问题二的圆盘移动步骤为：

-将Y上的62个盘子借助Z移动到X上；

-将最底下的第63个盘子从Y到Z；

-将X上的62个盘子借助Y移到Z上。

```c
#include<stdio.h>
#include<iostream>
using namespace std;
void move(int n,char a,char b,char c)
{
	if (1 == n)//限定条件
		cout << "从" << a << "到" << c << endl;
	else
	{
		move(n - 1, a, c, b);
		cout << "从" << a << "到" << c << endl;
		move(n - 1, b, a, c);
	}
}
int main()
{
	move(3,'x','y','z');
	return 0;
}
```

## 9.字符串算法

### 9.1BF算法

有两个字符串S和T，长度为N和M。首先S[1]和T[1]比较，如果相等，在比较S[2]和T[2]，直到T[M]为止；若不相等则S向右移动一个字符的位置，再进行比较。问题由模式串S决定，而不是由目标串T决定

### 9.2KMP算法

#### 9.2.1思路启发一

目标串T元素各不相同，回溯到T的下标1,即S失配点和T下标1重合。

目标串T第一个元素就失配，回溯到T的下标0,即S失配点和T下标0重合。

![思路启发一](C:\Users\admin\Desktop\数据结构与算法学习笔记\思路启发一.png)

#### 9.2.2思路启发二

T前缀和后缀(除失配点)有一个一样，回溯到T的下标2。

![思路启发二](C:\Users\admin\Desktop\数据结构与算法学习笔记\思路启发二.png)

#### 9.2.3思路启发三

T前缀和后缀(除失配点)有两个一样，回溯到T的下标3。

![思路启发三](C:\Users\admin\Desktop\数据结构与算法学习笔记\思路启发三.png)

#### 9.2.4思路启发四

前缀指除了最后一个字符的所有字符串组合，字符串T的判断字符串b为ssss，后缀是s,ss,sss,最长匹配是3，所以回溯到T的下标4

后缀定义和前缀一样，除了最前面的字符能组合的所有字符串，比如字符b的前缀是s,ss,sss,

然后下面填的数字是最长前后缀匹配字符串的长度+1

![思路启发四](C:\Users\admin\Desktop\数据结构与算法学习笔记\思路启发四.png)

k数组即为回溯点（即next数组），不用看T直接填写k

![回溯点](C:\Users\admin\Desktop\数据结构与算法学习笔记\回溯点.png)

#### 9.2.5KMP之next算法

![KMP之next算法](C:\Users\admin\Desktop\数据结构与算法学习笔记\KMP之next算法.png)

```c
void get_next(string T,int*next)
{
    int i=1;//后缀
    int j=0;//前缀,i,j都是下标
    next[1]=0;
    while(i<T[0])
    {
        if(j==0||T[i]==T[j])
        {
            i++;
            j++;
            next[i]=j;
        }
        else
        {
            j=next[j];
        }
    }
    //因为前缀是固定的，后缀是相对的
}
```

#### 9.2.6KMP算法实现//还有改进算法

```c++
#include <iostream>
using namespace std;

void get_next(string T, int* next)
{
	int i = 1, j = 0;
	next[1] = 0;
	while (i < T.length())
	{
		if (0 == j || T[i] == T[j])
		{
			i++; 
			j++;
			next[i] = j;
		}
		else
		{
			j = next[j];
		}
	}
}
//返回子串T在主串S在第pos字符之后的位置
int Index_KMP(string S, string T,int pos)
{
	int i = pos, j = 1;//i对应于S
	int next[255];
	get_next(T, next);

	while (i <= S[0]&&j<=T[0])
	{
		if (0==j||S[i] == T[j])
		{
			i++;
			j++;
		}
		else
		{
			j = next[j];
		}
	}
	if (j>T[0])
		return (i - pos);
	else
		return 0;
}

int main()
{
	char S[255] = " ababbaaaba" ;
	S[0] = 10;
	char T[255] = " aa";
	T[0] = 2;
	int p = Index_KMP(S, T, 2);
	cout << p << endl;
	return 0;
}
```

## 10.树

### 10.1树的表示法

#### 10.1.1 树的双亲表示法结构定义

![双亲表示法](C:\Users\admin\Desktop\数据结构与算法学习笔记\双亲表示法.png)

```c
#define MAX_TREE_SIZE 100
typedef char ElemType;

typedef struct PTNode
{
    ElemType data;//结点数据
    int parent;//双亲位置
}PTNode;

typedef struct
{
    PTNode nodes[MAX_TREE_SIZE];
    int r;//根的位置
    int n;//结点数目
}PTree;
```

#### 10.1.2 树的孩子表示法结构定义

![孩子表示法](C:\Users\admin\Desktop\数据结构与算法学习笔记\孩子表示法.png)

#### 10.1.3 树的双亲孩子表示法结构定义

![双亲孩子表示法](C:\Users\admin\Desktop\数据结构与算法学习笔记\双亲孩子表示法.png)

```c
#define MAX_TREE_SIZE 100

typedef char ElemType;

//孩子结点
typedef struct CTNode
{
    int child;			//孩子结点的下标
    struct CTNode *next;//指向下一个孩子结点的指针
}*ChildPtr;

//表头结构
typedef struct
{
    ElemType data;		//树中的结点数据
    int parent;			//双亲下标
    ChildPtr firstchild;//指向第一个孩子的指针
}CTBox;

//树结构
typedef struct
{
    CTBox nodes[MAX_TREE_SIZE];//结点数组
    int r,n;
}PCTree;
```

### 10.2二叉链表

![二叉链表](C:\Users\admin\Desktop\数据结构与算法学习笔记\二叉链表.png)

```c
typedef struct BitNode
{
    ElemType data;
    struct BitNode *lchild,*rchild;
}BitNode,*BiTree;
```

#### 10.2.1二叉树的遍历方法

#### （1）前序遍历-根左右

若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。![二叉树前序遍历](C:\Users\admin\Desktop\数据结构与算法学习笔记\二叉树前序遍历.png)

#### （2）中序遍历-左根右

若二叉树为空，则空操作返回，否则从根节点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。

![二叉树中序遍历](C:\Users\admin\Desktop\数据结构与算法学习笔记\二叉树中序遍历.png)

#### （3）后序遍历-左右根

若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根节点。

![二叉树后序遍历](C:\Users\admin\Desktop\数据结构与算法学习笔记\二叉树后序遍历.png)

#### 3）层序遍历

![二叉树层序遍历](C:\Users\admin\Desktop\数据结构与算法学习笔记\二叉树层序遍历.png)

### 10.3实战-二叉树的建立和遍历算法

![二叉树的建立和遍历算法](C:\Users\admin\Desktop\数据结构与算法学习笔记\二叉树的建立和遍历算法.png)

```c++
#include <iostream>//没弄出来
#include <stdio.h>
#include <stdlib.h>
using namespace std;

typedef char ElemType;
typedef struct BiTNode
{
    ElemType data;
    BiTNode* lchild, * rchild;
}BiTNode, * BiTree;

//创建一棵二叉树，约定用户按照前序遍历的方式输入数据
void CreateBiTree(BiTNode** T)//T是二级指针，一级指针的话函数一结束T的赋值就找不到了
{
    ElemType c;
    cin >> c;                                  //不能少ab c  de   **
    if (' ' == c)
    {
        *T = NULL;
    }
    else
    {
        *T = (BiTNode*)malloc(sizeof(BiTNode));//用(BiTree)malloc就不行
        (*T)->data = c;
        CreateBiTree(&(*T)->lchild);
        CreateBiTree(&(*T)->rchild);//->优先级高于&
    }

}

void visit(ElemType c, int level)
{
    cout << c << "位于第" << level << "层" << endl;
}
//前序遍历二叉树
void PreOrderTraverse(BiTNode* T, int level)
{
    if (T)
    {
        visit(T->data, level);
        PreOrderTraverse(T->lchild, level + 1);
        PreOrderTraverse(T->rchild, level + 1);
    }
}

int main()
{
    int level = 1;
    BiTNode* T = NULL;
    CreateBiTree(&T);
    PreOrderTraverse(T, level);

    return 0;
}
```

### 10.4线索二叉树及代码(中序遍历)

 通过考察各种二叉链表，不管儿叉树的形态如何，空链域的个数总是多过非空链域的个数。准确的说，各结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个。因此，提出了一种方法，利用原来的空链域存放指针，指向树中其他结点。这种指针称为线索。thread

![线索二叉树](C:\Users\admin\Desktop\数据结构与算法学习笔记\线索二叉树.png)

![线索二叉树结构示意图](C:\Users\admin\Desktop\数据结构与算法学习笔记\线索二叉树结构示意图.png)

```c
#include <iostream>//////////////////////有错

using namespace std;
//link-0,表示指向左右孩子的指针；
//Thread-1表示指向前驱后继的线索。
enum PointerTag{Link,Thread};
typedef char ElemType;
typedef struct BiThrNode
{
	ElemType data;
	BiThrNode* lchild, * rchild;
	PointerTag ltag,rtag;
}BiThrNode,*BiThrTree;//别名
//全局变量，始终指向刚刚访问过的结点
BiThrTree pre;

void CreateBiThrTree(BiThrTree* T)
{
	ElemType c;
	cin >> c;
	if (' ' == c)
	{
		*T = NULL;
	}
	else
	{
		*T = (BiThrTree)malloc(sizeof(BiThrNode));
		(*T)->data = c;//->优先级高于*
		(*T)->ltag = Link;
		(*T)->rtag = Link;
		CreateBiThrTree(&(*T)->lchild);
		CreateBiThrTree(&(*T)->rchild);
	}
}
void InThreading(BiThrTree T)
{
	if (T)
	{
		InThreading(T->lchild);
		if (!T->lchild)//如果该结点没有左孩子，中序遍历线索化
		{
			T->ltag = Thread;
			T->lchild = pre;
		}
		if (!pre->rchild)
		{
			pre->rtag = Thread;
			pre->rchild = T;
		}
		pre = T;
		InThreading(T->rchild);
	}
}
void InOrderThreading(BiThrTree* p, BiThrTree T)
{
	*p = (BiThrTree)malloc(sizeof(BiThrNode));
	(*p)->ltag = Link;
	(*p)->rtag = Thread;
	(*p)->rchild = *p;
	if (!T)
	{
		(*p)->lchild = *p;
	}
	else
	{
		(*p)->lchild = T;
		pre = *p;
		InThreading(T);
		pre->rchild = *p;
		pre->rtag = Thread;
		(*p)->rchild = pre;
	}
}

int main()
{
	BiThrTree T = NULL;
	CreateBiThrTree(&T);
	BiThrTree p = NULL;
	InOrderThreading(&p,T);

	return 0;
}
```

![IMG_20201020_182020](C:\Users\admin\Desktop\数据结构与算法学习笔记\IMG_20201020_182020.jpg)

![IMG_20201020_182023~1](C:\Users\admin\Desktop\数据结构与算法学习笔记\IMG_20201020_182023~1.jpg)

### 10.5赫夫曼树编码(最优二叉树)

![赫夫曼树与编码](C:\Users\admin\Desktop\数据结构与算法学习笔记\赫夫曼树与编码.png)

### 10.6赫夫曼树代码实现

pQueue.h

```c++
#pragma once
#ifndef _PQUEUE_H
#define _PQUEUE_H
#include "huffman.h"
#define TYPE htNode *
#define MAX_SZ 256
typedef struct _pQueueNode
{
	TYPE val;
	unsigned int priority;
	struct _pQueueNode *next;
}pQueueNode;
typedef struct _pQueue
{
	unsigned int size;//queue的长度
	pQueueNode *first;
}pQueue;
void initPQueue(pQueue **queue);
void addPQueue(pQueue **queue, TYPE val, unsigned int priority);
TYPE getPQueue(pQueue **queue);
#endif
```

qQueue.cpp

```c++
#include "pQueue.h"
#include <stdlib.h>
#include <stdio.h>
void initPQueue(pQueue **queue)
{
	(*queue) = (pQueue *) malloc(sizeof(pQueue));
	(*queue)->first = NULL;
	(*queue)->size = 0;
	return;
}
void addPQueue(pQueue **queue, TYPE val, unsigned int priority)
{
	if((*queue)->size == MAX_SZ)
	{
		printf("\nQueue is full.\n");
		return;
	}
	pQueueNode *aux = (pQueueNode *)malloc(sizeof(pQueueNode));
	aux->priority = priority;
	aux->val = val;
	if((*queue)->size == 0 || (*queue)->first == NULL)
	{
		aux->next = NULL;
		(*queue)->first = aux;
		(*queue)->size = 1;
		return;
	}
	else
	{
		if(priority<=(*queue)->first->priority)//priority小的放前面
		{
			aux->next = (*queue)->first;
			(*queue)->first = aux;
			(*queue)->size++;
			return;
		}
		else
		{
			pQueueNode * iterator = (*queue)->first;//迭代器
			while(iterator->next!=NULL)
			{
				if(priority<=iterator->next->priority)//priority小的放前面
				{
					aux->next = iterator->next;
					iterator->next = aux;
					(*queue)->size++;
					return;
				}
				iterator = iterator->next;
			}
			if(iterator->next == NULL)
			{
					aux->next = NULL;
					iterator->next = aux;
					(*queue)->size++;
					return;
			}
		}
	}
}
TYPE getPQueue(pQueue **queue)
{
	TYPE returnValue;
	if((*queue)->size>0)
	{
		returnValue = (*queue)->first->val;
		(*queue)->first = (*queue)->first->next;
		(*queue)->size--;
	}
	else
	{
		printf("\nQueue is empty.\n");
	}
	return returnValue;
}
```

huffman.h

```c
#pragma once//和#ifndef _HUFFMAN_H效果一样
#ifndef _HUFFMAN_H
#define _HUFFMAN_H
typedef struct _htNode {
	char symbol;
	struct _htNode *left, *right;
}htNode;
typedef struct _htTree {
	htNode *root;
}htTree;
typedef struct _hlNode {
	char symbol;
	char *code;
	struct _hlNode *next;
}hlNode;
typedef struct _hlTable {
	hlNode *first;
	hlNode *last;
}hlTable;

htTree * buildTree(char *inputString);
hlTable * buildTable(htTree *huffmanTree);
void encode(hlTable *table, char *stringToEncode);
void decode(htTree *tree, char *stringToDecode);

#endif
```

huffman.cpp

```c++
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "huffman.h"
#include "pQueue.h"

void traverseTree(htNode *treeNode, hlTable **table, int k, char code[256])
{
	if(treeNode->left == NULL && treeNode->right == NULL)
	{
		code[k] = '\0';
		hlNode *aux = (hlNode *)malloc(sizeof(hlNode));
		aux->code = (char *)malloc(sizeof(char)*(strlen(code)+1));
		strcpy(aux->code,code);
		aux->symbol = treeNode->symbol;
		aux->next = NULL;
		if((*table)->first == NULL)
		{
			(*table)->first = aux;
			(*table)->last = aux;
		}
		else
		{
			(*table)->last->next = aux;
			(*table)->last = aux;
		}
	}
	if(treeNode->left!=NULL)
	{
		code[k]='0';
		traverseTree(treeNode->left,table,k+1,code);
	}
	if(treeNode->right!=NULL)
	{
		code[k]='1';
		traverseTree(treeNode->right,table,k+1,code);
	}
}
hlTable * buildTable(htTree * huffmanTree)
{
	hlTable *table = (hlTable *)malloc(sizeof(hlTable));
	table->first = NULL;
	table->last = NULL;
	char code[256];
	int k=0;
	traverseTree(huffmanTree->root,&table,k,code);
	return table;
}
htTree * buildTree(char *inputString)
{
	int * probability = (int *)malloc(sizeof(int)*256);
	for(int i=0; i<256; i++)//初始化
    {
        probability[i]=0;//出现次数
    }
	for(int i=0; inputString[i]!='\0'; i++)//统计字符串字符出现次数
	{
	    probability[(unsigned char) inputString[i]]++;
	}
	pQueue * huffmanQueue;//队列的头指针
	initPQueue(&huffmanQueue);
	for(int i=0; i<256; i++)//填充队列
		if(probability[i]!=0)
		{
			htNode *aux = (htNode *)malloc(sizeof(htNode));
			aux->left = NULL;
			aux->right = NULL;
			aux->symbol = (char) i;
			addPQueue(&huffmanQueue,aux,probability[i]);
		}
	free(probability);
	while(huffmanQueue->size!=1)//生成赫夫曼树
	{
		int priority = huffmanQueue->first->priority;
		priority+=huffmanQueue->first->next->priority;
		htNode *left = getPQueue(&huffmanQueue);//获取第一个元素
		htNode *right = getPQueue(&huffmanQueue);//获取第二个元素
		htNode *newNode = (htNode *)malloc(sizeof(htNode));
		newNode->left = left;
		newNode->right = right;
		addPQueue(&huffmanQueue,newNode,priority);
	}
	htTree *tree = (htTree *) malloc(sizeof(htTree));
	tree->root = getPQueue(&huffmanQueue);//获取最后的元素
	return tree;
}
void encode(hlTable *table, char *stringToEncode)
{
	hlNode *traversal;
	printf("\nEncoding\nInput string : %s\nEncoded string : \n",stringToEncode);
	for(int i=0; stringToEncode[i]!='\0'; i++)
	{
		traversal = table->first;
		while(traversal->symbol != stringToEncode[i])
			traversal = traversal->next;
		printf("%s",traversal->code);
	}
	printf("\n");
}
void decode(htTree *tree, char *stringToDecode)
{
	htNode *traversal = tree->root;

	printf("\nDecoding\nInput string : %s\nDecoded string : \n",stringToDecode);
	for(int i=0; stringToDecode[i]!='\0'; i++)
	{
		if(traversal->left == NULL && traversal->right == NULL)
		{
			printf("%c",traversal->symbol);
			traversal = tree->root;
		}
		if(stringToDecode[i] == '0')
			traversal = traversal->left;

		if(stringToDecode[i] == '1')
			traversal = traversal->right;

		if(stringToDecode[i]!='0'&&stringToDecode[i]!='1')
		{
			printf("The input string is not coded correctly!\n");
			return;
		}
	}
	if(traversal->left == NULL && traversal->right == NULL)
	{
		printf("%c",traversal->symbol);
		traversal = tree->root;
	}
	printf("\n");
}
```

main.cpp

```c++
#include <stdio.h>
#include <stdlib.h>
#include "huffman.h"

int main(void)
{
	htTree *codeTree = buildTree("I love FishC.com!");
	hlTable *codeTable = buildTable(codeTree);
	encode(codeTable,"I love FishC.com!");
	decode(codeTree,"0011111000111");
	return 0;
}
```

## 11.图

### 11.1图的存储结构

#### 11.1.1邻接矩阵（无向图）	

vertex--顶点，link--边或弧

用两个数组来表示图，一个一维数组表示图中顶点信息，一个二维数组存储图中的边或弧的信息。

![图存储结构-邻接表示法](C:\Users\admin\Desktop\数据结构与算法学习笔记\图存储结构-邻接表示法.png)

```c++
#define INFINITY INT_MAX //最大值 无穷大
#define MAX_VERTEX_NUM 20 //最大顶点个数
typedef enum{DG,DN,UDG,UDN} GraphKind;//{有向图，有向网，无向图，无向网}
typedef struct ArcCell
{
    VRType adj;//VRType是顶点关系类型。对无权图，用0或1
    			//对带权图，则为权值类型
    InfoType *info;//该弧相关信息的指针,为零则各弧不含其他信息
}ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

typedef struct
{
    VertexType vexs[MAX_VERTEX_NUM];//顶点向量
    AdjMatrix arcs;//邻接矩阵
    int vexnum,arcnum;//图的当前顶点数和弧数
    GraphKind kind;//图的种类标志
}MGraph;

//找到顶点v的对应下标
int LocateVex(MGraph &G,char v)
{
	for (int i = 0; i < G.vexnum; i++)
		if (G.vexs[i] == v)
			return i;
}
```



#### 11.1.2邻接表（无向图）

图的一种链式存储结构（图的结构同上）

![邻接表](C:\Users\admin\Desktop\数据结构与算法学习笔记\邻接表.png)

#### 11.1.3邻接表（有向图）

邻接表-以顶点为弧尾

![邻接表（有向图）](C:\Users\admin\Desktop\数据结构与算法学习笔记\邻接表（有向图）.png)

逆邻接表-以顶点为弧头

![邻接表弧头（有向图）](C:\Users\admin\Desktop\数据结构与算法学习笔记\邻接表弧头（有向图）.png)

#### 11.1.4邻接表（网）

![邻接表-网](C:\Users\admin\Desktop\数据结构与算法学习笔记\邻接表-网.png)

#### 11.1.5十字链表

![十字链表](C:\Users\admin\Desktop\数据结构与算法学习笔记\十字链表.png)

```c
//十字链表存储结构
#define MAX_VERTEX_NUM 20
typedef struct ArcBox
{
    int tailVex,headVex;
    struct ArcBox *hlink,*tlink;
    InfoType *info;//该弧相关信息的指针
}ArcBox;

typedef struct vexNode
{
    VertexType data;
    struct ArcBox *firstin;
    struct ArcBox *firstout;
}vexNode;

typedef struct
{
    vexNode xlist[MAX_VERTEX_NUM];//表头向量
    int vexnum,arcnum;
}OLGraph;
```

#### 11.1.6邻接多重表

对边表结构进行改装，便于删除边

![邻接多重表](C:\Users\admin\Desktop\数据结构与算法学习笔记\邻接多重表.png)

邻接多重表

![邻接多重表-图](C:\Users\admin\Desktop\数据结构与算法学习笔记\邻接多重表-图.png)

#### 11.1.7边集数组

![边集数组](C:\Users\admin\Desktop\数据结构与算法学习笔记\边集数组.png)

### 11.2图的遍历

#### 11.2.1深度优先遍历(DFS)

DepthFirstSearch

顺序：ABCDEFGH G F E D I D C B A

![深度优先遍历](C:\Users\admin\Desktop\数据结构与算法学习笔记\深度优先遍历.png)

```c
//算法深度优先搜索遍历连通图的递归算法

#include <iostream>
using namespace std;

#define MVNum 100				 					//最大顶点数
typedef char VerTexType;							//假设顶点的数据类型为字符型 
typedef int ArcType;                 				//假设边的权值类型为整型 

typedef struct{ 
	VerTexType vexs[MVNum];            				//顶点表 
	ArcType arcs[MVNum][MVNum];      				//邻接矩阵 
	int vexnum,arcnum;                				//图的当前点数和边数 
}Graph;
 
bool visited[MVNum];           					//访问标志数组，其初值为"false" 
int FirstAdjVex(Graph G , int v);				//返回v的第一个邻接点
int NextAdjVex(Graph G , int v , int w);		//返回v相对于w的下一个邻接点

int LocateVex(Graph G , VerTexType v){
	//确定点v在G中的位置
	for(int i = 0; i < G.vexnum; ++i)
		if(G.vexs[i] == v)
			return i;
		return -1;
}//LocateVex

void CreateUDN(Graph &G){ 
    //采用邻接矩阵表示法，创建无向网G 
	int i , j , k;
	cout <<"请输入总顶点数，总边数 , 以空格隔开:";
    cin >> G.vexnum >> G.arcnum;						 //输入总顶点数，总边数
	cout << endl;

	cout << "输入点的名称，如 a：" << endl;

    for(i = 0; i < G.vexnum; ++i){   
		cout << "请输入第" << (i+1) << "个点的名称:";
		cin >> G.vexs[i];                        		 //依次输入点的信息 
	}
	cout << endl;

    for(i = 0; i < G.vexnum; ++i)                		 //初始化邻接矩阵，边的权值均置为极大值MaxInt 
		for(j = 0; j < G.vexnum; ++j)   
			G.arcs[i][j] = 0;  
	cout << "输入边依附的顶点，如：a b" << endl;
	for(k = 0; k < G.arcnum;++k){						 //构造邻接矩阵 
		VerTexType v1 , v2;
		cout << "请输入第" << (k + 1) << "条边依附的顶点:";
		cin >> v1 >> v2;								 //输入一条边依附的顶点及权值
		i = LocateVex(G, v1);  j = LocateVex(G, v2);	 //确定v1和v2在G中的位置，即顶点数组的下标 
		G.arcs[j][i] = G.arcs[i][j] = 1;                 //置<v1, v2>的对称边<v2, v1>的权值为w 
	}//for
}//CreateUDN 

void DFS(Graph G, int v){        			//从第v个顶点出发递归地深度优先遍历图G 
	cout << G.vexs[v] << "    ";  visited[v] = true;   	//访问第v个顶点，并置访问标志数组相应分量值为true 
	int w;
	for(w = FirstAdjVex(G, v);  w >= 0;  w = NextAdjVex(G, v, w))  
		//依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点 
		//NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点 
		if(!visited[w])
		 DFS(G, w);    					//对v的尚未访问的邻接顶点w递归调用DFS 
}//DFS

int FirstAdjVex(Graph G , int v){
	int i;
	for(i = 0 ; i < G.vexnum ; ++i){
		if(G.arcs[v][i] == 1 && visited[i] == false)
			return i;
	}
	return -1;
}//FirstAdjVex

int NextAdjVex(Graph G , int v , int w){//v行号，w列
	int i;
	for(i = w ; i < G.vexnum ; ++i){
		if(G.arcs[v][i] == 1 && visited[i] == false)
			return i;
	}
	return -1;
}//NextAdjVex

int main(){
	cout << "************算法深度优先搜索遍历连通图的递归算法**************" << endl << endl;
	Graph G;
	CreateUDN(G);
	cout << endl;
	cout << "无向连通图G创建完成！" << endl << endl;
	
	cout << "请输入遍历连通图的起始点：";
	VerTexType c;
	cin >> c;

	int i;
	for(i = 0 ; i < G.vexnum ; ++i){
		if(c == G.vexs[i])
			break;
	}
	cout << endl;
	while(i >= G.vexnum){
		cout << "该点不存在，请重新输入！" << endl;
		cout << "请输入遍历连通图的起始点：";
		cin >> c;
		for(i = 0 ; i < G.vexnum ; ++i){
			if(c == G.vexs[i])
				break;
		}
	}
	cout << "深度优先搜索遍历连通图结果：" << endl;
	DFS(G , i);

	cout <<endl;
	return 0;
}//main
```

#### 11.2.2深度优先遍历实例

![深度优先遍历实例](C:\Users\admin\Desktop\数据结构与算法学习笔记\深度优先遍历实例.jpg)

### 11.3马踏棋盘//错了

深度优先遍历

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define X 8
#define Y 8
int chess[X][Y];
//找到基于（x，y）下一个可走的位置
int nextxy(int* x, int* y, int count)
{
    switch (count)
    {
    case 3:
        if (*x + 2 <= X - 1 && *y - 1 >= 0 && chess[*x + 2][*y - 1] == 0)
        {
            *x += 2;
            *y -= 1;
            return 1;
        }
        break;
    case 4:
        if (*x + 2 <= X - 1 && *y + 1 <= Y - 1 && chess[*x + 2][*y + 1] == 0)
        {
            *x += 2;
            *y += 1;
            return 1;
        }
        break;
    case 1:
        if (*x - 1 >= 0 && *y - 2 >= 0 && chess[*x - 1][*y - 2] == 0)
        {
            *x -= 1;
            *y -= 2;
            return 1;
        }
        break;
    case 2:
        if (*x + 1 <= X - 1 && *y - 2 >= 0 && chess[*x + 1][*y - 2] == 0)
        {
            *x += 1;
            *y -= 2;
            return 1;
        }
        break;
    case 5:
        if (*x + 1 <= X - 1 && *y + 2 <= Y - 1 && chess[*x + 1][*y + 2] == 0)
        {
            *x += 1;
            *y += 2;
            return 1;
        }
        break;
    case 6:
        if (*x - 1 >= 0 && *y + 2 <= Y - 1 && chess[*x - 1][*y + 2] == 0)
        {
            *x -= 1;
            *y += 2;
            return 1;
        }
        break;
    case 7:
        if (*x - 2 >= 0 && *y + 1 <= Y - 1 && chess[*x - 2][*y + 1] == 0)
        {
            *x -= 2;
            *y += 1;
            return 1;
        }
        break;
    case 8:
        if (*x - 2 >= 0 && *y - 1 >= 0 && chess[*x - 2][*y - 1] == 0)
        {
            *x -= 2;
            *y -= 1;
            return 1;
        }
        break;
    default:
        break;
    }
    return 0;
}
void print()
{
    int i, j;
    for (i = 0; i < X; i++)
    {
        for (j = 0; j < Y; j++)
        {
            printf("%2d\t", chess[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}
//深度优先遍历棋盘，（x，y）为位置坐标，tag为标记变量，每走一步，tag+1
int TravelChessBoard(int x, int y, int tag)
{
    int x1 = x, y1 = y, flag = 0, count = 1;
    chess[x][y] = tag;
    if (X * Y == tag)
    {
        //打印棋盘
        print();
        return 1;
    }
    flag = nextxy(&x1, &y1, count);
    while (flag == 0 && count < 8)
    {
        count++;
        flag = nextxy(&x1, &y1, count);
    }
    while (flag)
    {
        if (TravelChessBoard(x1, y1, tag + 1))
        {
            return 1;
        }
        //继续找到马的下一步可走的坐标（x1,y1）
        x1 = x;
        y1 = y;
        count++;
        flag = nextxy(&x1, &y1, count);
        while (flag == 0 && count < 8)
        {
            count++;
            flag = nextxy(&x1, &y1, count);
        }
    }
    if (flag == 0)
    {
        chess[x][y] = 0;
    }
    return 0;
}
int main()
{
    int i, j;
    clock_t start, finish;
    start = clock();
    for (i = 0; i < X; i++)
    {
        for (j = 0; j < Y; j++)
        {
            chess[i][j] = 0;
        }
    }
    if (!TravelChessBoard(1, 0, 1))
    {
        printf("抱歉，马踏棋盘算法失败鸟~\n");
    }
    finish = clock();
    printf("本次耗时%f秒\n",(double)(finish-start)/CLOCKS_PER_SEC);//运行时间
    return 0;
}

```

### 11.4广度优先遍历

广度优先搜索，BreadthFirstSearch

![广度优先遍历1](C:\Users\admin\Desktop\数据结构与算法学习笔记\广度优先遍历1.png)

![广度优先遍历](C:\Users\admin\Desktop\数据结构与算法学习笔记\广度优先遍历.png)

```c
#include<stdio.h>
#include<stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

#define MAXVEX 100

typedef int DataType;	/*设置队数据类型，可修改*/
typedef int VexType;
typedef int EdgeType;
typedef struct{
	DataType data[MAXVEX];
	int front;
	int rear; 
}Queue;				/*定义栈结构体*/

typedef struct{
	VexType ves[MAXVEX];	/*顶点表*/
	EdgeType edge[MAXVEX][MAXVEX];	/*边表*/
	int v;				/*结点数*/
	int e;				/*边数*/
}MGraph;					/*邻接矩阵*/
 
void Ini_Queue(Queue *Q){		/*创建队*/
	Q->front=Q->rear=0;
}

int In_Queue(Queue *Q,DataType e){	/*入队*/
	if(Q->front!=(Q->rear+1)%MAXVEX){
		Q->data[Q->rear]=e;
		Q->rear=(Q->rear+1)%MAXVEX;
		return OK;	
	}
	else return FALSE;
}

int Empty_Queue(Queue Q){			/*判队空*/
	if(Q.front==Q.rear)	return TRUE;
	else return FALSE;
}

int Out_Queue(Queue *Q,DataType *e){	/*出队*/
	if(Empty_Queue(*Q))	return FALSE;
	else {
		*e=Q->data[Q->front];
		Q->front=(Q->front+1)%MAXVEX;
	}
	return TRUE;
}

int Creat_MGraph(MGraph *M){		/*创建邻接矩阵*/
	int i,j,k;
	printf("请输入结点个数和边数(v,e)：");
	scanf("%d%d",&(M->v),&(M->e));		/*输入顶点数与边数*/
	printf("键入结点表信息:\n");	
	for(i=0;i<M->v;i++)			/*创建顶点表*/
	scanf("%d",&(M->ves[i]));
	for(i=0;i<M->v;i++)
		for(j=0;j<M->v;j++) 
			M->edge[i][j]=0;		/*初始化边表全为0*/	 
	printf("键入边表信息（格式：i,j,范围（1-n）:\n");
	for(k=0;k<M->e;k++){			/*创建边表*/
		scanf("%d%d",&i,&j);
		M->edge[i-1][j-1]=1;		/*填充edge[i][j]上的边*/
		M->edge[j-1][i-1]=1;		/*填充edge[i][j]上的边*/
	}
	return OK;
}

void Mprint(MGraph M)
{	//打印邻接矩阵
	for(int i=0;i<M.v;i++)
	 {
	 	 printf("________________________________________\n");
	 	 for(int j=0;j<M.v;j++)
		 printf("|%-3d|",M.edge[i][j]); 
		 printf("\n");
	 }
	 printf("________________________________________\n");
}


int visit[MAXVEX]={FALSE};		/*visit数组标记顶点访问情况*/ 

int BFSM(MGraph M,DataType V){	/*广度优先遍历算法*/ 
	int i;
	DataType k=V;
	for(i=0;i<M.v;i++)			/*将标记数组置为false*/
		visit[i]=FALSE;
	Queue Q;
	Ini_Queue(&Q);			/*初始化队*/
	In_Queue(&Q,k);			/*入队开始结点的序号*/
	while(!Empty_Queue(Q)){
		Out_Queue(&Q,&k);	/*先出队一个顶点序号*/
		printf("%d ",M.ves[k-1]);
		visit[k-1]=TRUE;		/*将已经访问的顶点标记为true*/
		for(i=0;i<M.v;i++)		/*将已被访问的顶点的未被访问的邻接点入队*/
			if(!visit[i]&&M.edge[k-1][i]==1)	
			In_Queue(&Q,i+1);	
	}
	return OK;				/*当队中不在有元素，则遍历结束*/ 
}

int main(){		/*测试*/
	MGraph M;
	DataType V;
	Creat_MGraph(&M);
	Mprint(M); 
	while(1){
		printf("\n请输入一个开始结点的序号:(范围1--结点数,超过该范围退出程序):");
		scanf("%d",&V);
		if(V>M.v)return 0;		/*大于结点数退出程序*/ 
		BFSM(M,V);
	}
	 return 0;
}
/*
样例输入：
5 4

1 2 3 4 5 

1 3
2 3
2 5
2 4

以第三个结点开始: 3
得到	3 1 2 4 5 
*/
```

### 11.5最小生成树(普里姆算法)

**更适合与解决边的绸密度更高的连通网。**

构造最小生成树一定有下面两个特点：

1、尽量选取最小的权值的边，并且不能有回路

2、n个顶点只选取n-1条边。

![普利姆算法](C:\Users\admin\Desktop\数据结构与算法学习笔记\普利姆算法.png)

![普利姆算法笔记 (2)](C:\Users\admin\Desktop\数据结构与算法学习笔记\普利姆算法笔记 (2).jpg)



```c
#include <stdio.h>
#define MAXVEX 100			// 最大顶点数
#define INFINITY 65535		// 用65535来代表无穷大
typedef struct
{
	char vexs[MAXVEX];				// 顶点表
	int arc[MAXVEX][MAXVEX];		// 邻接矩阵
	int numVertexes, numEdges;		// 图中当前的顶点数和边数
} MGraph;
// 建立无向网图的邻接矩阵
MGraph CreateMGraph(MGraph G)
{
	int i, j, k, w;
	printf("请输入顶点数：\n");
	scanf("%d",&G.numVertexes);
	printf("请输入边数：\n");
	scanf("%d",&G.numEdges);
	printf("请输入顶点名称：\n");
	for( i=0; i < G.numVertexes;i++ )
	{
		scanf("%c",&G.vexs[i]);
		getchar();
		printf("请输入顶点名称：\n");
	}

	for( i=0; i < G.numVertexes; i++ )
	{
		for( j=0; j < G.numVertexes; j++ )
		{
			G.arc[i][j] = INFINITY;	// 邻接矩阵初始化
		}
	}

	for( k=0; k < G.numEdges; k++ )
	{
		printf("请输入边(Vi,Vj)上的下标i,下标j和对应的权w:\n");// 这只是例子，提高用户体验需要进行改善
		scanf("%d",&i);
		scanf("%d",&j);
		scanf("%d",&w);
		G.arc[i][j] = w;
		G.arc[j][i] = G.arc[i][j];			// 是无向网图，对称矩阵
	}
    return G;
}

void MiniSpanTree_Prim(MGraph G)
{
    int min,i,j,k;
    int adjvex[MAXVEX];//保存相关顶点下标[0,0,1,0,0,0,1,0,1]
    int lowcost[MAXVEX];//保存相关顶点权值
    lowcost[0]=0;//vo最为最小生成树的根开始遍历，权值为0
    adjvex[0]=0;
    for(i=1;i<G.numVertexes;i++)//初始化
    {
        lowcost[i]=G.arc[0][i];
        adjvex[i]=0;
    }
    for(i=1;i<G.numVertexes;i++)
    {
        min=INFINITY;//初始化最小权值![普利姆算法笔记](C:\Users\admin\Desktop\数据结构与算法学习笔记\普利姆算法笔记.jpg)
        j=1;
        k=0;
        while(j<G.numVertexes)
        {
            if(lowcost[j]!=0 && lowcost[j]<min)
            {
                min=lowcost[j];
                k=j;
            }
            j++;
        }
        printf("(%d,%d)",adjvex[k],k);
        lowcost[k]=0;
        for(j=0;j<G.numVertexes;j++)
        {
            if(lowcost[j]!=0 && G.arc[k][j]<lowcost[j])
            {
                lowcost[j]=G.arc[k][j];
                adjvex[j]=k;
            }
        }
    }
}
int main()
{
    MGraph G;
    MiniSpanTree_Prim(CreateMGraph(G));
    return 0;
}
```

### 11.6克鲁斯卡尔算法Kruskal

**更适合于求边稀疏的网的最小生成树。**

本算法初始为只含顶点不含边的森林（个数与顶点个数一样）



**并查集**（Union-Find set）这个数据结构可以方便快速的解决这个问题。基本的处理思想是：初始时把每个对象看作是一个单元素集合；然后依次按顺序读入联通边，将连通边中的两个元素合并。在此过程中将重复使用一个**搜索**（Find）运算，确定一个集合在那个集合中。当读入一个连通边（ｕ，ｖ）时，先判断ｕ和ｖ是否在同一个集合中，如果是则不用合并；如果不是，则用一个**合并**（Union）运算把ｕ、ｖ所在集合合并，使得这两个集合中的任意两个元素都连通。因此并查集在处理时，主要用到**搜索**和**合并**两个运算。

![克鲁斯卡尔算法](C:\Users\admin\Desktop\数据结构与算法学习笔记\克鲁斯卡尔算法.png)

```c
//不理解
#include <stdio.h>
#define MAXVEX 100
#define MAXEDGE 2000
#define INFINITY 65535
typedef struct
{
    int s;//begin
    int e;//end
    int w;//weight
}Edge;
typedef struct
{
	char vexs[MAXVEX];
	Edge edge[MAXEDGE];
	int numVertexes, numEdges;
} MGraph;
MGraph CreateMGraph(MGraph G)
{
	int i, j, k, m;
	printf("请输入顶点数：\n");
	scanf("%d",&G.numVertexes);
	printf("请输入边数：\n");
	scanf("%d",&G.numEdges);
	printf("请输入顶点名称：\n");
	for( i=0; i < G.numVertexes;i++ )
	{
		scanf("%c",&G.vexs[i]);
		getchar();
		printf("请输入顶点名称：\n");
	}
	for( k=0; k < G.numEdges; k++ )
	{
		printf("请按权值   从低到高   输入边%d的begin,end和对应的权weight:\n",k);
		scanf("%d %d %d",&i,&j,&m);
		G.edge[k].s = i;
		G.edge[k].e = j;
		G.edge[k].w = m;
	}
    return G;
}
int Find(int *parent,int f)
{
    while(parent[f]>0)
    {
        f=parent[f];
    }
    return f;
}
void MiniSpanTree_Kruskal(MGraph G)
{
    int i,n,m;
    int parent[MAXVEX];//定义parent数组用来判断边与边是否形成回路
    for(i=0;i<G.numVertexes;i++)//初始化
    {
        parent[i]=0;
    }
    for(i=0;i<G.numEdges;i++)
    {
        n=Find(parent,G.edge[i].s);
        m=Find(parent,G.edge[i].e);
        if(n!=m)
        {
            parent[n]=m;
            printf("(%d,%d) %d ",G.edge[i].s,G.edge[i].e,G.edge[i].w);
        }
    }
}
int main()
{
    MGraph G;
    MiniSpanTree_Kruskal(CreateMGraph(G));
    return 0;
}
```

![克鲁斯卡尔1](C:\Users\admin\Desktop\数据结构与算法学习笔记\克鲁斯卡尔1.jpg)



### 11.7贪心算法

**贪心选择性质**

一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次的选择可以依赖以前作出的选择，但不依赖于后面要作出的选择。这就是贪心选择性质。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解 [4]  。

贪心算法也存在如下问题： 

1、不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑 ；

2、贪心算法一般用来解决求最大或最小解 ；

3、贪心算法只能确定某些问题的可行性范围  。

### 11.8最短路径(迪杰斯特拉算法)

**给定源点和终点**的最短路径

一个顶点到所有顶点的最短距离



![迪杰斯特拉算法2](C:\Users\admin\Desktop\数据结构与算法学习笔记\迪杰斯特拉算法2.png)

![迪杰斯特拉算法1](C:\Users\admin\Desktop\数据结构与算法学习笔记\迪杰斯特拉算法1.png)

D         0 	1	4	7	5	8	10	12	16

P		  0	0	1	 4	2	4	3	   6	  7

final    1	1	 1 	1	1	1	1	   1	  1



```c
#include <stdio.h>
#define MAXVEX 100
#define INFINITY 65535
typedef int Patharc[MAXVEX];//用于存储最短路径下标的数组
typedef int ShortPathTable[MAXVEX];	//用于存储到各点最短路径的权值和
typedef struct
{
	char vexs[MAXVEX];
	int arc[MAXVEX][MAXVEX];
	int numVertexes, numEdges;
} MGraph;
MGraph CreateMGraph(MGraph G)
{
	int i, j, k, w;
	printf("请输入顶点数：\n");
	scanf("%d",&G.numVertexes);
	printf("请输入边数：\n");
	scanf("%d",&G.numEdges);
	printf("请输入顶点名称：\n");
	for( i=0; i < G.numVertexes;i++ )
	{
		scanf("%c",&G.vexs[i]);
		getchar();
		printf("请输入顶点名称：\n");
	}
	for( i=0; i < G.numVertexes; i++ )
	{
		for( j=0; j < G.numVertexes; j++ )
		{
			G.arc[i][j] = INFINITY;
			if(i==j)
            {
                G.arc[i][j]=0;
            }
		}
	}
	for( k=0; k < G.numEdges; k++ )
	{
		printf("请输入边(Vi,Vj)上的下标i,下标j和对应的权w:\n");
		scanf("%d %d %d",&i,&j,&w);
		G.arc[i][j] = w;
		G.arc[j][i] = G.arc[i][j];
	}
    return G;
}
void ShortestPath_Dijkstar(MGraph G,int V0)
{
    int i,v,w,k,min;
    Patharc p;//用于存储最短路径下标的数组
    ShortPathTable D;//用于存储到各点最短路径的权值和
    int final[MAXVEX];//final[w]=1表示已经找到从V0到w结点的最短路径了
    for(v=0;v<G.numVertexes;v++)
    {
        final[v]=0;//所有顶点初始化为未找到最短路径
        D[v]=G.arc[V0][v];//读取与V0点相连的所有权值
        p[v]=0;//初始化路径数组为零
    }
    D[V0]=0;//V0至V0路径权值0
    final[V0]=1;//V0至V0不需要求路径
    for(v=1;v<G.numVertexes;v++)
    {
        min=INFINITY;
        for(w=0;w<G.numVertexes;w++)
        {
            if(!final[w] && D[w]<min)
            {
                k=w;
                min=D[w];
            }
        }
        final[k]=1;//将目前找到的最近结点都置1
        //修正当前最短路径及距离
        for(w=0;w<G.numVertexes;w++)
        {
            //如果经过v点的路径比现在这条路径短的话，更新1
            if(!final[w] && (min+G.arc[k][w]<D[w]))
            {
                D[w]=min+G.arc[k][w];//修改当前路径长度
                p[w]=k;//存放前驱顶点
            }
        }
    }
    for(i=1;i<G.numVertexes;i++)
    {
        printf("V%d->",p[i]);
    }
    printf("V8\n");
    printf("最短路径为%d",D[8]);
}
int main()
{
    MGraph G;
    ShortestPath_Dijkstar(CreateMGraph(G),0);
    return 0;
}

```

### 11.9弗洛伊德算法

所有顶点到所有顶点的最短路径

![弗洛伊德算法](C:\Users\admin\Desktop\数据结构与算法学习笔记\弗洛伊德算法.png)

![弗洛伊德算法1](C:\Users\admin\Desktop\数据结构与算法学习笔记\弗洛伊德算法1.png)



```c
#include <stdio.h
#define MAXVEX 100
#define INFINITY 65535
typedef int Pathmatrix[MAXVEX][MAXVEX];
typedef int ShortPathTable[MAXVEX][MAXVEX];
typedef struct
{
	char vexs[MAXVEX];
	int arc[MAXVEX][MAXVEX];
	int numVertexes, numEdges;
} MGraph;
MGraph CreateMGraph(MGraph G)
{
	int i, j, k, w;
	printf("请输入顶点数：\n");
	scanf("%d",&G.numVertexes);
	printf("请输入边数：\n");
	scanf("%d",&G.numEdges);
	for( i=0; i < G.numVertexes; i++ )
	{
		for( j=0; j < G.numVertexes; j++ )
		{
			G.arc[i][j] = INFINITY;
			if(i==j)
            {
                G.arc[i][j]=0;
            }
		}
	}
	for( k=0; k < G.numEdges; k++ )
	{
		printf("请输入边(Vi,Vj)上的下标i,下标j和对应的权w:\n");
		scanf("%d %d %d",&i,&j,&w);
		G.arc[i][j] = w;
		G.arc[j][i] = G.arc[i][j];
	}
    return G;
}
void ShortestPath_Floyd(MGraph G)
{
    int v,w,k;
    Pathmatrix p;//记录对应点的最小路径的前驱点，例如p(1,3) = 2 说明顶点1到顶点3的最小路径要经过2 
    ShortPathTable D;//记录顶点间的最小路径值
    for(v=0;v<G.numVertexes;v++)
    {
        for(w=0;w<G.numVertexes;w++)
        {
            D[v][w]=G.arc[v][w];
            p[v][w]=w;
        }
    }
    for(k=0;k<G.numVertexes;k++)
    {
        for(v=0;v<G.numVertexes;v++)
        {
            for(w=0;w<G.numVertexes;w++)
            {
                if(D[v][w]>D[v][k]+D[k][w])
                {
                    D[v][w]=D[v][k]+D[k][w];
                    p[v][w]=p[v][k];
                }
            }
        }
    }
    for (v=0;v<G.numVertexes;v++)
    {
        for (w =v+1;w<G.numVertexes;w++)
        {
            printf("\nV%d-->V%d  weight:%d\n",v,w,D[v][w]);
            k = p[v][w];
            printf("Path:V%d",v);
            while (k != w)
            {
                printf("-->V%d",k);
                k = p[k][w];
            }
            printf("-->V%d",w);

        }
    }
}
int main()
{
    MGraph G;
    ShortestPath_Floyd(CreateMGraph(G));
    return 0;
}

```

### 11.10拓扑排序

对一个[有向无环图](https://baike.baidu.com/item/有向无环图/10972513)(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个[偏序](https://baike.baidu.com/item/偏序/2439087)得到该集合上的一个[全序](https://baike.baidu.com/item/全序/10577699)，这个操作称之为拓扑排序。

AOV网：Activity On Vertex Network

在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，一个工程常被分为多个小的子工程，这些子工程被称为活动（Activity)，在有向图中若以顶点表示活动，有向边表示活动之间的先后关系，这样的图简称为AOV网。

![拓扑排序-树](C:\Users\admin\Desktop\数据结构与算法学习笔记\拓扑排序-树.png)

![拓扑排序-邻接表](C:\Users\admin\Desktop\数据结构与算法学习笔记\拓扑排序-邻接表.png)



```c
#include <stdio.h>
#include <stdlib.h>
#define MAXVEX 100
#define ERROR 1
#define OK 0
typedef struct EdgeNode
{
    int adjvex;
    struct EdgeNode *next;
}EdgeNode;
typedef struct VextexNode
{
    int in;
    int data;
    EdgeNode *firstedge;
}VextexNode,AdjList[MAXVEX];
typedef struct
{
    AdjList adjlist;
    int numVertexes,numEdges;
}graphAdjList;
int LocateVex(graphAdjList G,char &v1)
{
    int i;
    for(i=0;i<G.numVertexes;i++)
    {
        if(G.adjlist[i].data==v1)
            return i;
    }
    if(i>=G.numVertexes)
        return ERROR;
    else
        return 0;
}
graphAdjList CreateDG(graphAdjList G)
{
    EdgeNode *p,*q;
    char v1,v2;
    char v;
    int i,j,k,n,m;
    printf("请输入图的顶点数和弧数：\n");
    scanf("%d %d",&G.numVertexes,&G.numEdges);
    printf("请输入顶点：");
    getchar();
    for(i=0;i<G.numVertexes;i++)
    {
        scanf("%c",&v);   //输入顶点名字
        getchar();
        G.adjlist[i].data=v;
        G.adjlist[i].firstedge=NULL;
    }
    printf("请输入顶点入度：");
    for(i=0;i<G.numVertexes;i++)
    {
        scanf("%d",&m);
        getchar();
        G.adjlist[i].in=m;
    }
    printf("请输入弧尾和弧头：");
    for(k=0;k<G.numEdges;k++) //创建边，并连接头结点
    {
        scanf("%c %c",&v1,&v2);  //v1为弧尾
        getchar();  //v2为弧头
        i=LocateVex(G,v1);
        j=LocateVex(G,v2);
        if(G.adjlist[i].firstedge==NULL)  //如果链表为空新建一个表节点，让头节点的指针指向该表节点
        {
            p=(EdgeNode *)new EdgeNode;
            G.adjlist[i].firstedge=p;
            q=G.adjlist[i].firstedge;
        }
        else
        {
            q=G.adjlist[i].firstedge;//获取头结点的表头指针
            for(n=0;n<G.numEdges;n++,q=q->next)//将q指针移动至链表的尾巴处
            {
                if(!q->next)
                    break;
            }
            p=(EdgeNode *)new EdgeNode;
            q->next=p; //将该边（弧）加入到链表中
            q=q->next;
        }
        q->adjvex=j;  //记录弧头的索引
        q->next=NULL;
    }
    printf("图构建成功！\n");
    return G;
}
int TopologicalSort(graphAdjList G)
{
    EdgeNode *e;
    int i,k,gettop;
    int top=0;
    int count=0;
    int *stack;
    stack=(int *)malloc(G.numVertexes*sizeof(int));
    for(i=0;i<G.numVertexes;i++)
    {
        if(0==G.adjlist[i].in)
        {
            stack[++top]=i;
        }
    }
    while(top!=0)
    {
        gettop=stack[top--];
        printf("%c->",G.adjlist[gettop].data);
        count++;
        for(e=G.adjlist[gettop].firstedge;e;e=e->next)
        {
            k=e->adjvex;
            if(!(--G.adjlist[k].in))
            {
                stack[++top]=k;
            }
        }
    }
    if(count<G.numVertexes)
    {
        return ERROR;
    }
    else
    {
        return OK;
    }
}
int main()
{
    graphAdjList G;
    TopologicalSort(CreateDG(G));
    return 0;
}

```

### 11.11关键路径

AOE网：Activity On **Edge** Network

在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，一个工程常被分为多个小的子工程，这些子工程被称为活动（Activity)，在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图简称为AOE网。

AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。

![关键路径四个关键词](C:\Users\admin\Desktop\数据结构与算法学习笔记\关键路径四个关键词.png)



![关键路径](C:\Users\admin\Desktop\数据结构与算法学习笔记\关键路径.png)

etv从源点开始，取最大的；

ltv借助于etv从汇点开始,并且取最小的。ltv-e->weight

比如C1->ltv  !=  1,因为会耽误1->2->5的工期



![关键路径四个关键词之二](C:\Users\admin\Desktop\数据结构与算法学习笔记\关键路径四个关键词之二.png)

ete借助于etv；

lte借助于ete从右往左算；

纠错：a3->lte==1；

![关键路径邻接表1](C:\Users\admin\Desktop\数据结构与算法学习笔记\关键路径邻接表1.png)

**邻接表结点第一个元素表示节点下标。**** **权值放在路径的尾结点结构体中****



![关键路径结果](C:\Users\admin\Desktop\数据结构与算法学习笔记\关键路径结果.png)

结果输出条件，ete和lte相等



```c
#include <stdio.h>
#include <stdlib.h>
#define MAXVEX 100
#define ERROR 1
#define OK 0
typedef struct EdgeNode
{
    int adjvex;//邻接顶点坐标
    int weight;
    struct EdgeNode *next;
}EdgeNode;
typedef struct VextexNode
{
    int in;
    int data;
    EdgeNode *firstedge;
}VextexNode,AdjList[MAXVEX];
typedef struct
{
    AdjList adjlist;
    int numVertexes,numEdges;
}graphAdjList;
int *etv,*ltv;
int *stack2;//存储拓扑序列的栈
int top2;//用于stack2的栈顶指针
int LocateVex(graphAdjList G,char &v1)
{
    int i;
    for(i=0;i<G.numVertexes;i++)
    {
        if(G.adjlist[i].data==v1)
            return i;
    }
    if(i>=G.numVertexes)
        return ERROR;
    else
        return 0;
}
graphAdjList CreateDG(graphAdjList G)
{
    EdgeNode *p,*q;
    char v1,v2;
    char v;
    int i,j,k,n,m,w;
    printf("请输入图的顶点数和弧数：\n");
    scanf("%d %d",&G.numVertexes,&G.numEdges);
    printf("请输入顶点：");
    getchar();
    for(i=0;i<G.numVertexes;i++)
    {
        scanf("%c",&v);   //输入顶点名字
        getchar();
        G.adjlist[i].data=v;
        G.adjlist[i].firstedge=NULL;
    }
    printf("请输入顶点入度：");
    for(i=0;i<G.numVertexes;i++)
    {
        scanf("%d",&m);
        getchar();
        G.adjlist[i].in=m;
    }
    printf("请输入弧尾、弧头和权值：");
    for(k=0;k<G.numEdges;k++) //创建边，并连接头结点
    {
        scanf("%c %c %d",&v1,&v2,&w);  //v1为弧尾
        getchar();  //v2为弧头
        i=LocateVex(G,v1);
        j=LocateVex(G,v2);
        if(G.adjlist[i].firstedge==NULL)  //如果链表为空新建一个表节点，让头节点的指针指向该表节点
        {
            p=(EdgeNode *)new EdgeNode;
            G.adjlist[i].firstedge=p;
            q=G.adjlist[i].firstedge;
        }
        else
        {
            q=G.adjlist[i].firstedge;//获取头结点的表头指针
            for(n=0;n<G.numEdges;n++,q=q->next)//将q指针移动至链表的尾巴处
            {
                if(!q->next)
                    break;
            }
            p=(EdgeNode *)new EdgeNode;
            q->next=p; //将该边（弧）加入到链表中
            q=q->next;
        }
        q->adjvex=j;
        q->weight=w;
        q->next=NULL;
    }
    printf("图构建成功！\n");
    return G;
}
int TopologicalSort(graphAdjList G)
{
    EdgeNode *e;
    int i,k,gettop;
    int top=0;//用于统计指针下标索引
    int count=0;//用于统计输出顶点个数
    int *stack;//用于存储输出为0的顶点
    stack=(int *)malloc(G.numVertexes*sizeof(int));
    for(i=0;i<G.numVertexes;i++)
    {
        if(0==G.adjlist[i].in)
        {
            stack[++top]=i;//将度为0的顶点入栈
        }
    }
    //初始化etv都为0
    top2=0;
    etv=(int *)malloc(G.numVertexes*sizeof(int));
    for(i=0;i<G.numVertexes;i++)
    {
        etv[i]=0;
    }
    stack2=(int*)malloc(G.numVertexes*sizeof(int));
    while(top!=0)
    {
        gettop=stack[top--];    //出栈
        stack2[++top2]=gettop;  //保存拓扑序列顺序
        count++;
        for(e=G.adjlist[gettop].firstedge;e;e=e->next)
        {
            k=e->adjvex;//取结点下标
            if(!(--G.adjlist[k].in))
            {
                stack[++top]=k;
            }
            if((etv[gettop]+e->weight)>etv[k])
            {
                etv[k]=etv[gettop]+e->weight;
            }
        }
    }
    if(count<G.numVertexes)     //如果count小于顶点数，说明存在环
    {
        return ERROR;
    }
    else
    {
        return OK;
    }
}
void CriticalPath(graphAdjList G)
{
    EdgeNode *e;
    int i,gettop,k,j;
    int ete,lte;
    TopologicalSort(G);

    //初始化ltv都为汇点的时间
    ltv=(int *)malloc(G.numVertexes*sizeof(int));
    for(i=0;i<G.numVertexes;i++)
    {
        ltv[i]=etv[G.numVertexes-1];
    }
    //从汇点倒过来逐个计算ltv
    while(0!=top2)
    {
        gettop=stack2[top2--];   //第一个出栈是汇点
        for(e=G.adjlist[gettop].firstedge;e;e=e->next)
        {
            k=e->adjvex;
            if((ltv[k]-e->weight)<ltv[gettop])//取最小的
            {
                ltv[gettop]=ltv[k]-e->weight;
            }
        }
    }
    //通过etv和ltv求ete和lte
    for(j=0;j<G.numVertexes;j++)
    {
        for(e=G.adjlist[j].firstedge;e;e=e->next)
        {
            k=e->adjvex;
            ete=etv[j];
            lte=ltv[k]-e->weight;
            if(ete==lte)
            {
                printf("<%c,%c> length:%d,",G.adjlist[j].data,G.adjlist[k].data,e->weight);
            }
        }
    }
}
int main()
{
    graphAdjList G;
    CriticalPath(CreateDG(G));
    return 0;
}

```

## 12.查找

### 12.1一般查找

```c
#include <stdio.h>
#include <stdlib.h>
struct Student
{
    int id;
    char name[100];
    int score;
};
int Sq_Srearch(int *a,int n,int key)
{
    int i=n;
    a[0]=key;
    while(a[i]!=key)
    {
        i--;
    }
    return i;
}
int main()
{
    int i,j;
    Student student[4]=
    {
        {1024,"小甲鱼",100},
        {1026,"秋舞斜阳",60},
        {1028,"黑夜",100},
        {1030,"迷途",60}
    };
    printf("请输入要查询的学号：");
    scanf("%d",&j);
    i=Sq_Srearch(*student.id,4,int j);
    printf("学号为%d\n",j);
    printf("姓名为%c\n",student.name[i]);
    printf("成绩为%d\n",student.score[i]);
    return 0;
}

```

### 12.2插值查找

```c
#include <stdio.h>
int bin_search(int str[],int n,int key)
{
    int low,high,mid;
    low=0;
    high=n-1;
    while(low<=high)
    {
        mid=low+(key-str[low])/(str[high]-str[low])*(high-low);
        if(str[mid]==key)
            return mid;
        if(str[mid]<key)
            low=mid+1;
        if(str[mid]>key)
            high=mid-1;
    }
    return -1;
}
int main()
{
    int i,j;
    int a[11]={1,1,2,3,5,8,13,21,34,55,89};
    printf("请输入你要查找的数：");
    scanf("%d",&i);
    j=bin_search(a,10,i);
    printf("%d",j);
    return 0;
}
```

12.3斐波那契查找

```c
#include <stdio.h>
#define MAXSIZE 20
void fibonacci(int *f)
{
	int i;
	f[0]=1;
	f[1]=1;
	for(i=2;i<MAXSIZE;++i)
	{
		f[i]=f[i-2]+f[i-1];
	}
}
int fibonacci_search(int *a,int key,int n)
{
	int low=0;
	int high=n-1;
	int mid=0;
	int k=0;
	int F[MAXSIZE];
	int i;
	fibonacci(F);
	while(n>F[k]-1)
	{
		++k;
	}
	for(i=n;i<F[k]-1;++i)
	{
		a[i]=a[high];
	}
	while(low<=high)
	{
		mid=low+F[k-1]- 1;

		if(a[mid]>key)
		{
			high=mid-1;
			k=k-1;
		}
		else if(a[mid]<key)
		{
			low=mid+1;
			k=k-2;
		}
		else
		{
			if(mid<=high)
			{
				return mid;
			}
			else
			{
				return high;
			}
		}
	}
	return -1;
}
int main()
{
	int a[MAXSIZE]={1,5,15,22,25,31,39,42,47,49,59,68,88};
	int key;
	int pos;
	printf("请输入要查找的数字:");
	scanf("%d",&key);
	pos = fibonacci_search(a,key,13);
	if(pos!=-1)
	{
		printf("\n查找成功，可喜可贺，可口可乐! 关键字 %d 所在的位置是: %d\n\n", key, pos);
	}
	else
	{
		printf("\nO~No~~小的办事不力，未在数组中找到元素:%d\n\n", key);
	}
	return 0;
}
```

### 12.3线性索引查找

![分块索引](C:\Users\admin\Desktop\数据结构与算法学习笔记\分块索引.png)

### 12.4二叉排序树

![二叉排序树](C:\Users\admin\Desktop\数据结构与算法学习笔记\二叉排序树.png)

第一个元素放在双亲结点，比他小的放左子树，大的放右子树；其他以此类推。

中序遍历输出

binary sort tree

二叉排序树的查找、插入和删除

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
//递归查找二叉排序树T中是否存在key
//f指向T的双亲，其初始调用值为NULL；
//若查找成功，则指针p指向该元素结点，并返回true
//否则指向路径上最后一个结点，返回false
bool SearchBST(BiTree T,int key,BiTree f,BiTree &p)
{
    if(!T)
    {
        p=f;
        return false;
    }
    else if(key==T->data)
    {
        p=T;
        return true;
    }
    else if(key<T->data)
    {
        return SearchBST(T->lchild,key,T,p);
    }
    else
    {
        return SearchBST(T->rchild,key,T,p);
    }
}
int InsertBST(BiTree &T,int key)
{
    BiTree p,s;
    if(!SearchBST(T,key,NULL,&p))//查找不到key，
    {
        s=(BiTree)malloc(sizeof(BiTNode));
        s->data=key;
        s->lchild=s->rchild=NULL;
        if (p==NULL)//表空的情况下直接插入
        {
            T=s;
        }
        else if(key<p->data)
        {
            p->lchild=s;
        }
        else
        {
            p->rchild=s;
        }
        return 0;
    }
    else
    {
        return -1;
    }
}
void InOrderTraverse(BiTree T)
{
    if(T)
    {
        InOrderTraverse(T->lchild);
        printf("%d ",T->data);
        InOrderTraverse(T->rchild);
    }
}
bool Delete(BiTree &T)//T的地址改了，外面还要用，所以传入地址
{
    BiTree q,s;
    if((*T)->rchild==NULL)
    {
        q=(*T);
        T=(*T)->lchild;
        free(q);
    }
    else if((*T)->lchild==NULL)
    {
        q=(*T);
        T=(*T)->rchild;
        free(q);
    }
    else	//要删除的结点有左子树和右子树，那么用直接前驱结点或直接后继结点替换都行
    {
        q=(*T);
        s=(*T)->lchild;//这里用直接前驱结点s
        while(s->rchild)//q获取直接前驱的双亲
        {
            q=s;
            s=s->rchild;
        }
        (*T)->data=s->data;
        if(q!=(*T))		
        {
            q->rchild=s->lchild;
        }
        else				//q和*T重合时，*T的左子树的第一个节点没有右子树
        {
            q->lchild=s->lchild;
        }
        free(s);
    }
    return true;
}
bool DeleteBST(BiTree T,int key)
{
    if(T==NULL)
    {
        return false;
    }
    else
    {
        if(key==T->data)
        {
            return Delete(T);
        }
        else if(key<T->data)
        {
            return DeleteBST(T->lchild,key);
        }
        else
        {
            return DeleteBST(T->rchild,key);
        }
    }
}
int main()
{
    int i,j,a[101],n;
    char opp;
    BiTree T;
    printf("请选择：\n");
    printf("1、建立二叉排序树并按顺序输出。\n");
    printf("2、在二叉排序树插入元素并按顺序输出。\n");
    printf("3、在二叉排序树删除元素并按顺序输出。\n");
    printf("4、退出。\n");
    while(opp!='0')
    {
        scanf("%c",&opp);
        switch(opp)
        {
        case'1':
            printf("请输入数组长度：");
            scanf("%d",&n);
            T=NULL;
            for(i=1;i<=n;i++)
            {
                printf("\n");
                printf("请输入第%d个元素：",i);
                scanf("%d",&a[i]);
                InsertBST(T,a[i]);
            }
            getchar();
            printf("按顺序输出为：");
            InOrderTraverse(T);
            printf("\n");
            break;
        case'2':
            printf("请输入要插入的元素：");
            scanf("%d",&j);
            InsertBST(T,j);
            getchar();
            printf("按顺序输出为：");
            InOrderTraverse(T);
            printf("\n");
            break;
        case'3':
            printf("请输入要删除的元素：");
            scanf("%d",&j);
            DeleteBST(T,j);
            getchar();
            printf("按顺序输出为：");
            InOrderTraverse(T);
            printf("\n");
            break;
        case'4':
            exit(0);
        }
    }
    return 0;
}

```

### 12.5平衡二叉排序树(AVL)-过

#### 12.5.1定义

![平衡排序二叉树](C:\Users\admin\Desktop\数据结构与算法学习笔记\平衡排序二叉树.png)

#### 12.5.2例子

![平衡二叉树例子](C:\Users\admin\Desktop\数据结构与算法学习笔记\平衡二叉树例子.png)

**在构建平衡二叉树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树，在保持二叉排序树特性的前提下，调整关系。**

平衡因子BF：左子树的深度比右子树的深度大于2，也就是最小不平衡树的顶点的平衡因子为2

![例子结果](C:\Users\admin\Desktop\数据结构与算法学习笔记\例子结果.png)



```c
#include <stdio.h>
#include <stdlib.h>
#define LH 1//左子树高
#define EH 0//等高
#define RH -1
bool *taller=(bool*)malloc(sizeof(bool));//观察插入节点树变高了没
typedef struct BiTNode
{
    int data;
    int bf;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
void R_Rotate(BiTree &T)
{
    BiTree L;
    L=T->lchild;
    T->lchild=L->rchild;
    L->rchild=T;
    T=L;
}
void L_Rotate(BiTree &T)
{
    BiTree L;
    L=T->rchild;
    T->rchild=L->lchild;
    L->lchild=T;
    T=L;
}
void LeftBalance(BiTree &T)
{
    BiTree L,Lr;
    L=T->lchild;
    switch(L->bf)
    {
    case LH:
        T->bf=L->bf=EH;
        R_Rotate(T);
        break;
    case RH:
        Lr=L->rchild;
        switch(Lr->bf)
        {
        case LH:
            T->bf=RH;
            L->bf=EH;
            break;
        case EH:
            T->bf=L->bf=EH;
            break;
        case RH:
            T->bf=EH;
            L->bf=LH;
            break;
        }
        Lr->bf=EH;
        L_Rotate(T->lchild);
        R_Rotate(T);
        break;
    }
}
void RightBalance(BiTree &T)
{
    BiTree L,Lr;
    L=T->rchild;
    switch(L->bf)
    {
    case RH:
        T->bf=L->bf=EH;
        L_Rotate(T);
        break;
    case LH:
        Lr=L->lchild;
        switch(Lr->bf)
        {
        case LH:
            T->bf=EH;
            L->bf=RH;
            break;
        case EH:
            T->bf=L->bf=EH;
            break;
        case RH:
            T->bf=LH;
            L->bf=EH;
            break;
        }
        Lr->bf=EH;
        R_Rotate(T->rchild);
        L_Rotate(T);
        break;
    }
}
bool InsertAVL(BiTree &T,int e,bool *taller)
{
    if(T==NULL)
    {
        T=(BiTree)malloc(sizeof(BiTNode));
        T->data=e;
        T->lchild=T->rchild=NULL;
        T->bf=EH;
        *taller=true;
    }
    else
    {
        if(e==T->data)
        {
            *taller=false;
            return false;
        }
        else if(e<T->data)
        {
            if(!InsertAVL(T->lchild,e,taller))
                return false;
            if(*taller)
            {
                switch(T->bf)
                {
                case LH:
                    LeftBalance(T);
                    *taller=false;
                    break;
                case EH:
                    T->bf=LH;
                    *taller=true;
                    break;
                case RH:
                    T->bf=EH;
                    *taller=false;
                    break;
                }
             }
         }
         else
         {
            if(!InsertAVL(T->rchild,e,taller))
                return false;
            if(*taller)
            {
                switch(T->bf)
                {
                case LH:
                    T->bf=EH;
                    *taller=false;
                    break;
                case EH:
                    T->bf=RH;
                    *taller=true;
                    break;
                case RH:
                    RightBalance(T);
                    *taller=false;
                    break;
                }
             }
          }
    }
    return true;
}
void InOrderTraverse(BiTree T)
{
    if(T)
    {
        InOrderTraverse(T->lchild);
        printf("%d ",T->data);
        InOrderTraverse(T->rchild);
    }
}
int main()
{
    int a[101],n;
    BiTree T=NULL;
    printf("请输入数组长度：");
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        printf("\n");
        printf("请输入第%d个元素：",i);
        scanf("%d",&a[i]);
        InsertAVL(T,a[i],taller);
    }
        printf("按顺序输出为：");
        InOrderTraverse(T);
        printf("\n");
    return 0;
}

```

### 12.6多路查找树

特点是其每一个节点的孩子可以多余两个，且每一个节点可以存储多个元素

2-3树所有叶子都在同一层次，2-3二结点要么有两个孩子，要么没有孩子

2-3-4树

2-3树和2-3-4树是一种特殊的B树

![B树](C:\Users\admin\Desktop\数据结构与算法学习笔记\B树.png)

![B树0](C:\Users\admin\Desktop\数据结构与算法学习笔记\B树0.png)

![B树1](C:\Users\admin\Desktop\数据结构与算法学习笔记\B树1.png)

### 12.7散列表(哈希表查找)

[散列表](https://baike.baidu.com/item/散列表/10027933)（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组数组叫做[散列表](https://baike.baidu.com/item/散列表/10027933)。

给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。

```c
#include <stdio.h>
#include <stdlib.h>
#define HASHSIZE 12
#define NULLKEY 32768
typedef struct
{
    int *elem;
    int count;
}HashTable;
int InitHashTable(HashTable *H)
{
    H->count=HASHSIZE;
    H->elem=(int *)malloc(HASHSIZE*sizeof(int));
    if(!H->elem)
    {
        return -1;
    }
    for(int i=0;i<HASHSIZE;i++)
    {
        H->elem[i]=NULLKEY;
    }
    return 0;
}
int Hash(int key)
{
    return key%HASHSIZE;
}
void InsertHash(HashTable *H,int key)
{
    int addr;
    addr=Hash(key);
    while(H->elem[addr]!=NULLKEY)
    {
        addr=(addr+1)%HASHSIZE;
    }
    H->elem[addr]=key;
}
int SearchHash(HashTable *H,int key)
{
    int addr=Hash(key);
    while(H->elem[addr]!=key)
    {
        addr=(addr+1)%HASHSIZE;
        if(H->elem[addr]==NULLKEY || addr==Hash(key))
        {
            return -1;
        }
    }
    return addr;
}
int main()
{
    HashTable H;
    InitHashTable(&H);
    int i,m,n,p;
    for(i=0;i<HASHSIZE;i++)
    {
        printf("请输入第%d个元素",i);
        scanf("%d",&n);
        InsertHash(&H,n);
        printf("\n");
    }
    getchar();
    printf("散列表输入完成！\n");
    printf("请输入要查找的元素：");
    scanf("%d",&m);
    p=SearchHash(&H,m);
    if(p!=-1)
    {
        printf("查找成功，%d",p);
    }
    else
    {
        printf("查找失败！");
    }

    return 0;
}

```

## 13.排序

### 13.1排序原则

稳定性，排序前领先，排序后也领先

### 13.2冒泡排序

```c
#include <stdio.h>
#include <stdlib.h>
void BubbleSort1(int *k,int n)
{
    int i,j,temp,count1=0,count2=0;
    for(i=0;i<n-1;i++)
    {
        for(j=i+1;j<n;j++)
        {
            count1++;
            if(k[i]>k[j])
            {
                count2++;
                temp=k[j];
                k[j]=k[i];
                k[i]=temp;
            }
        }
    }
    printf("总共进行了%d次比较，进行了%d次移动\n",count1,count2);
}
void BubbleSort2(int *k,int n)
{
    int i,j,temp,count1=0,count2=0;
    bool flag=true;
    for(i=0;i<n-1&&flag;i++)
    {
        for(j=n-1;j>i;j--)
        {
            count1++;
            flag=false;
            if(k[j-1]>k[j])
            {
                count2++;
                temp=k[j];
                k[j]=k[j-1];
                k[j-1]=temp;
                flag=true;
            }
        }
    }
    printf("总共进行了%d次比较，进行了%d次移动\n",count1,count2);
}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    BubbleSort1(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    int b[10]={5,2,6,0,3,9,1,7,4,8};
    BubbleSort2(b,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

### 13.3选择排序

```c
#include <stdio.h>
#include <stdlib.h>
void SelectSort(int *k,int n)
{
    int i,j,min,temp,count1=0,count2=0;
    for(i=0;i<n-1;i++)
    {
        min=i;
        for(j=i+1;j<n;j++)
        {
            count1++;
            if(k[j]<k[min])
            {
                min=j;
            }
        }
        if(min!=i)
        {
            count2++;
            temp=k[i];
            k[i]=k[min];
            k[min]=temp;
        }
    }
    printf("总共进行了%d次比较，进行了%d次交换\n\n",count1,count2);
}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    SelectSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

### 13.4直接插入排序

```c
#include <stdio.h>
#include <stdlib.h>
void InsertSort(int *k,int n)
{
    int i,j,temp;
    for(i=1;i<n;i++)
    {
        if(k[i]<k[i-1])
        {
            temp=k[i];
            for(j=i-1;k[j]>temp;j--)
            {
                k[j+1]=k[j];
            }
            k[j+1]=temp;//上面的for循环结束后，j又减1
        }
    }
}
int main()
{
    int i;
    int a[3]={3,1,2};
    InsertSort(a,3);
    printf("排序后的结果是：");
    for(i=0;i<3;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

### 13.5希尔排序//过

是一种预处理

```c
#include <stdio.h>
#include <stdlib.h>
void ShellSort(int *k,int n)
{
    int i,j,temp,gap=n;
    do
    {
        gap=gap/3+1;
        for(i=gap;i<n;i++)//直接插入排序
        {
            if(k[i]<k[i-gap])
            {
                temp=k[i];
                for(j=i-gap;k[j]>temp;j-=gap)
                {
                    k[j+gap]=k[j];
                }
                k[j+gap]=temp;
            }
        }
    }while(gap>1);

}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    ShellSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

### 13.6堆排序

![堆排序定义](C:\Users\admin\Desktop\数据结构与算法学习笔记\堆排序定义.png)

大顶堆

![](C:\Users\admin\Desktop\数据结构与算法学习笔记\大顶堆.png)![小顶堆](C:\Users\admin\Desktop\数据结构与算法学习笔记\小顶堆.png)

小顶堆

![小顶堆](C:\Users\admin\Desktop\数据结构与算法学习笔记\小顶堆.png)

算法基本思想

![大顶堆思想](C:\Users\admin\Desktop\数据结构与算法学习笔记\大顶堆思想.png)

//大顶堆从下往上，从右往左

```c
#include <stdio.h>
#include <stdlib.h>
void swap(int *k,int i,int j)
{
    int temp;
    temp=k[i];
    k[i]=k[j];
    k[j]=temp;
}
void HeapAdjust(int *k,int s,int n)
{
    int i,temp=k[s];//k[2*s]为k[s]的左孩子，k[2*s+1]为k[s]的右孩子
    for(i=2*s;i<=n;i=i*2)
    {
        if(i<n && k[i]<k[i+1])//如果左孩子大于右孩子，不管
        {
            i++;
        }
        if(temp>=k[i])//如果双亲大于左右孩子最大的那个，否则交换值
        {
            break;
        }
        k[s]=k[i];
        s=i;
    }
    k[s]=temp;//双亲大于左右孩子最大的那个,互换
}
void HeapSort(int *k,int n)
{
    int i;
    for(i=n/2;i>0;i--)//构建大顶堆，（数组，结点，长度）
    {
        HeapAdjust(k,i,n);
    }
    for(i=n;i>1;i--)
    {
        swap(k,1,i);//第一个结点和最后一个互换
        HeapAdjust(k,1,i-1);
    }
}
int main()
{
    int i,a[10]={-1,5,2,6,0,3,9,1,7,4};
    HeapSort(a,9);
    printf("排序后的结果是：");
    for(i=1;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

### 13.7归并排序

![归并排序](C:\Users\admin\Desktop\数据结构与算法学习笔记\归并排序.png)



![归并排序1](C:\Users\admin\Desktop\数据结构与算法学习笔记\归并排序1.png)

#### 13.7.1递归实现

```c
#include <stdio.h>
#define MAXSIZE 10
//实现归并，把所有数据放在list1里面
void merging(int *list1,int list1_size,int *list2,int list2_size)
{
    int i=0,j=0,k=0,m;
    int temp[MAXSIZE];
    while(i<list1_size && j<list2_size)
    {
        if(list1[i]<list2[j])
        {
            temp[k++]=list1[i++];
        }
        else
        {
            temp[k++]=list2[j++];
        }
    }
    while(i<list1_size)
    {
        temp[k++]=list1[i++];
    }
    while(j<list2_size)
    {
        temp[k++]=list2[j++];
    }
    for(m=0;m<(list1_size+list2_size);m++)//把temp里面内容放进list1里面
    {
        list1[m]=temp[m];
    }
}
void MergeSort(int *k,int n)
{
    if(n>1)
    {
        int *list1=k;				//左边
        int list1_size=n/2;
        int *list2=k+n/2;			//右边
        int list2_size=n-list1_size;
        MergeSort(list1,list1_size);
        MergeSort(list2,list2_size);
        merging(list1,list1_size,list2,list2_size);
    }
}
int main()
{
    int i;
    int a[10]={5,2,6,0,3,9,1,7,4,8};
    MergeSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

#### 13.7.2迭代实现

--效率更高（过）

```c
#include <stdio.h>
#include<stdlib.h>
void MergeSort(int *k,int n)
{
    int i,next,left_min,left_max,right_min,right_max;//左边起始，左边结束，  ，  。
    int *temp=(int *)malloc(n*sizeof(int));
    for(i=1;i<n;i*=2)//i为步长
    {
        for(left_min=0;left_min<n-i;left_min=right_max)
        {
            right_min=left_max=left_min+i;
            right_max=left_max+i;
            if(right_max>n)
            {
                right_max=n;
            }
            next=0;
            while(left_min<left_max && right_min<right_max)
            {
                if(k[left_min]<k[right_min])
                {
                    temp[next++]=k[left_min++];
                }
                else
                {
                    temp[next++]=k[right_min++];
                }
            }
            while(left_min<left_max)
            {
                k[--right_min]=k[--left_max];
            }
            while(next>0)
            {
                k[--right_min]=temp[--next];
            }
        }
    }
}
int main()
{
    int i;
    int a[10]={5,2,6,0,3,9,1,7,4,8};
    MergeSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

### 13.8快速排序

思维导图

![思维导图](C:\Users\admin\Desktop\数据结构与算法学习笔记\思维导图.png)

#### 13.8.1快速排序

```c
#include <stdio.h>
void swap(int *k,int low,int high)
{
    int temp;
    temp=k[low];
    k[low]=k[high];
    k[high]=temp;
}
int Partition(int *k,int low,int high)
{
    int point;
    point=k[low];
    while(low<high)
    {
        while(low<high &&k[high]>=point)
        {
            high--;
        }
        swap(k,low,high);
        while(low<high &&k[low]<=point)
        {
            low++;
        }
        swap(k,low,high);
    }
    return low;
}
void Qsort(int *k,int low,int high)
{
    int point;
    if(low<high)
    {
        point=Partition(k,low,high);
        Qsort(k,low,point-1);
        Qsort(k,point+1,high);
    }
}
void QuickSort(int *k,int n)
{
    Qsort(k,0,n-1);
}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    QuickSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

#### 13.8.2快速排序优化1

```c
#include <stdio.h>
void swap(int *k,int low,int high)
{
    int temp;
    temp=k[low];
    k[low]=k[high];
    k[high]=temp;
}
int Partition(int *k,int low,int high)
{
    int point;
    int mid=low+(high-low)/2;
    if(k[low]>k[high])
    {
        swap(k,low,high);
    }
    if(k[mid]>k[high])
    {
        swap(k,mid,high);
    }
    if(k[mid]>k[low])
    {
        swap(k,mid,low);
    }
    point=k[low];
    while(low<high)
    {
        while(low<high &&k[high]>=point)
        {
            high--;
        }
        swap(k,low,high);
        while(low<high &&k[low]<=point)
        {
            low++;
        }
        swap(k,low,high);
    }
    return low;
}
void Qsort(int *k,int low,int high)
{
    int point;
    if(low<high)
    {
        point=Partition(k,low,high);
        Qsort(k,low,point-1);
        Qsort(k,point+1,high);
    }
}
void QuickSort(int *k,int n)
{
    Qsort(k,0,n-1);
}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    QuickSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```



#### 13.8.3快速排序优化2

```c
#include <stdio.h>
void swap(int *k,int low,int high)
{
    int temp;
    temp=k[low];
    k[low]=k[high];
    k[high]=temp;
}
int Partition(int *k,int low,int high)
{
    int point;
    /*int mid=low+(high-low)/2;
    if(k[low]>k[high])
    {
        swap(k,low,high);
    }
    if(k[mid]>k[high])
    {
        swap(k,mid,high);
    }
    if(k[mid]>k[low])
    {
        swap(k,mid,low);
    }*/
    point=k[low];
    while(low<high)
    {
        while(low<high &&k[high]>=point)
        {
            high--;
        }
        //swap(k,low,high);
        k[low]=k[high];
        while(low<high &&k[low]<=point)
        {
            low++;
        }
        //swap(k,low,high);
        k[high]=k[low];
    }
    k[low]=point;
    return low;
}
void Qsort(int *k,int low,int high)
{
    int point;
    if(low<high)
    {
        point=Partition(k,low,high);
        Qsort(k,low,point-1);
        Qsort(k,point+1,high);
    }
}
void QuickSort(int *k,int n)
{
    Qsort(k,0,n-1);
}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    QuickSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```



#### 13.8.4快速排序优化3

```c
#include <stdio.h>
#define MAXSIZE 7
void ISort(int *k,int n)
{
    int i,j,temp;
    for(i=1;i<n;i++)
    {
        if(k[i]<k[i-1])
        {
            temp=k[i];
            for(j=i-1;k[j]>temp;j--)
            {
                k[j+1]=k[j];
            }
            k[j+1]=temp;
        }
    }
}
void InsertSort(int *k,int low,int high)
{
    ISort(k+low,(high-low+1));
}
void swap(int *k,int low,int high)
{
    int temp;
    temp=k[low];
    k[low]=k[high];
    k[high]=temp;
}
int Partition(int *k,int low,int high)
{
    int point;
    int mid=low+(high-low)/2;
    if(k[low]>k[high])
    {
        swap(k,low,high);
    }
    if(k[mid]>k[high])
    {
        swap(k,mid,high);
    }
    if(k[mid]>k[low])
    {
        swap(k,mid,low);
    }
    point=k[low];
    while(low<high)
    {
        while(low<high &&k[high]>=point)
        {
            high--;
        }
        //swap(k,low,high);
        k[low]=k[high];
        while(low<high &&k[low]<=point)
        {
            low++;
        }
        //swap(k,low,high);
        k[high]=k[low];
    }
    k[low]=point;
    return low;
}
void Qsort(int *k,int low,int high)
{
    int point;
    if(high-low>MAXSIZE)
    {
        if(low<high)
        {
        point=Partition(k,low,high);
        Qsort(k,low,point-1);
        Qsort(k,point+1,high);
        }
    }
    else
    {
        InsertSort(k,low,high);
    }

}
void QuickSort(int *k,int n)
{
    Qsort(k,0,n-1);
}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    QuickSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

#### 13.8.5快速排序优化4

```c
#include <stdio.h>
#define MAXSIZE 7
void ISort(int *k,int n)
{
    int i,j,temp;
    for(i=1;i<n;i++)
    {
        if(k[i]<k[i-1])
        {
            temp=k[i];
            for(j=i-1;k[j]>temp;j--)
            {
                k[j+1]=k[j];
            }
            k[j+1]=temp;
        }
    }
}
void InsertSort(int *k,int low,int high)
{
    ISort(k+low,(high-low+1));
}
void swap(int *k,int low,int high)
{
    int temp;
    temp=k[low];
    k[low]=k[high];
    k[high]=temp;
}
int Partition(int *k,int low,int high)
{
    int point;
    int mid=low+(high-low)/2;
    if(k[low]>k[high])
    {
        swap(k,low,high);
    }
    if(k[mid]>k[high])
    {
        swap(k,mid,high);
    }
    if(k[mid]>k[low])
    {
        swap(k,mid,low);
    }
    point=k[low];
    while(low<high)
    {
        while(low<high &&k[high]>=point)
        {
            high--;
        }
        //swap(k,low,high);
        k[low]=k[high];
        while(low<high &&k[low]<=point)
        {
            low++;
        }
        //swap(k,low,high);
        k[high]=k[low];
    }
    k[low]=point;
    return low;
}
void Qsort(int *k,int low,int high)
{
    int point;
    if(high-low>MAXSIZE)
    {
        while(low<high)
        {
            point=Partition(k,low,high);
            if(point-low<high-point)
            {
                Qsort(k,low,point-1);
                //Qsort(k,point+1,high);
                low=point+1;
            }
            else
            {
                Qsort(k,point+1,high);
                high=point-1;
            }

        }
    }
    else
    {
        InsertSort(k,low,high);
    }

}
void QuickSort(int *k,int n)
{
    Qsort(k,0,n-1);
}
int main()
{
    int i,a[10]={5,2,6,0,3,9,1,7,4,8};
    QuickSort(a,10);
    printf("排序后的结果是：");
    for(i=0;i<10;i++)
    {
        printf("%d  ",a[i]);
    }
    printf("\n\n");
    return 0;
}

```

