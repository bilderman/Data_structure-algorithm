## 一、线性表1

### 1.1并集

```c++
unionL(*L1,L2)
{
  int length1,length2,i;
  ElementType e;
  length1=ListLength(L1);
  length2=ListLength(L2);
  for(int i=1;i<=length2;i++)
  {
     GetElem(L2,i,&e);
       if( !LocateElem(*L1,e))
	{
	  ListInsert(*L1,++length1,e);
	}		
  }
}
```

### 1.2插入线性表元素

```c+
//时间复杂度O(n)
//线性表从一开始，数组从零开始
Typedef OK true;
Typedef error false;
Status ListInsert(SqList *L , int i , ElementType e)
{
    if(L->length==MAXSIZE)
    {
    	return error;
	}
	if(i<1||i>L->length+1)
	{
    	return error;
	}
	if(i>=1&&i<=L->length)//在线性表之内,不是队尾
	{
		for(int k=L->length-1;k>=i-1;k--)
		L.data[k+1]=L.data[k];
	}
	L[i-1]=e;
	L->length++;
	
	return OK;
}
```



### 1.3删除线性表元素

```c+
//时间复杂度O(n)
Status ListDelete(SqList *L,int i,ElementType *e)
{
	if(L->length==MINSIZE)
	{
		return ERROR;
	}
	if(i<1||i>L->length+1)
	{
		return ERROR;
	}
	*e=L->data[i-1];//相当于回收站，储存删除的元素
	if(i<L->length)
	{
		for(int k=i;k<=L->length;k++)
		{
			L->data[k-1]=L->data[k];
		}
	}
	
	L->length--;
	return OK;
}
```

### 1.4单链表定义

头指针---头结点【数据域（一般放长度）|指针域】---第一个数据结点【数据域|指针域】········



***如果定义如下：***
***A *p则使用：p->play(); 左边是结构指针。***
***A p 则使用：p.paly(); 左边是结构变量。***
***总结：***
***箭头（->）：左边必须为指针；***
***点号（.）：左边必须为实体。***

```c++
typedef struct Node
{
    ElemType data;//数据域
    struct Node *next;    
}Node;
typedef struct Node* LinkList;
```

### 1.5单链表查找元素

```c++
//时间复杂度O(n)
Status GetElem(LinkList L,int i,EleType *e)
{
    LinkList p;//指向头结点的 头指针
    p=L->next;//p为第一个数据结点
    int j=1;
    
    while(p && j<i)
    {
        p=p->next;
        j++;
    }
    if(!p||j>i)
    {
        return ERROR;
    }
    
    *e=p->data;
    return OK;
}
```

### 1.6头插法建立单链表//数据顺序相反

```
//*L为头结点
void CreateListHead(LinkList *L,int n)//L为双指针，用于给实参地址传递，不用返回值,相当于头指针
{
	LinkList p;
	srand(time(0));
	
	*L=(LinkList)malloc(sizeof(Node));//配所需的内存空间,并返回一个指向它的指针。
	(*L)->next=NULL;//*的优先级不高
	
	for(int i=0;i<n;i++)
	{
		p=(LinkList)malloc(sizeof(Node));
		p->data=rand()%100+1;
		p->next=(*L)->next;
		(*L)->next=p;
	}
}
```

### 1.7尾插法建立单链表

```c++
void CreateListTail(LinkList *L,int n)//L为双指针，用于给实参地址传递，不用返回值相当于头指针
{
	LinkList p,r;
	srand(time(0));
	
	*L=(LinkList)malloc(sizeof(Node));//配所需的内存空间,并返回一个指向它的指针。
	r=*L
	
	for(int i=0;i<n;i++)
	{
		p=(LinkList)malloc(sizeof(Node));
		p->data=rand()%100+1;
		r->next=p;
		r=p;
	}
    r->next=NULL;
}
```

### 1.8单链表的整表删除

```c
void ClearList(LinkList *L)
{
    LinkList p,q;
    p=(*L);
    
    while(p)
    {
        q=p->next;
        free(p);
        p=q;
    }
    
    (*L)->next=NULL;
    return OK;
}
```

### 3.1单链表例题--寻找中间单链表节点数据//包括头结点

```c
Status GetMidNode(LinkList L,ElemType *e)
{
    LinkList search,mid;
    search=mid=L;
    while(search->next!=NULL)
    {
        if(search->next->next!=NULL)
        {
            search=search->next->next;
            mid=mid->next;
        }
        else
        {
            search=search->next;
        }
    }
    *e=mid->data;
    return OK;
}
```

### 二、静态链表

用数组描述的链表，即称为静态链表。
在C语言中，静态链表的表现形式即为结构体数组，结构体变量包括数据域data和游标CUR。

下标为零的游标是第一个备用列表的下标，下标为MAXSIZE-1的游标是第一个非空数据的下标，最后一个非零元素的游标是零。(0的游标cur-第一个空元素下标，999-第一个有元素下标，最后一个有元素-0)

### 2.1静态链表定义（线性表的静态链表存储结构）

```c
#define MAXSIZE 1000
typedef struct
{
    ElemType data;
    int cur;//游标cursor
}Component,StaticLinkList[MAXSIZE];
```



### 2.2静态链表初始化

```c
Status InitList(StaticLinkList space)
{
    int i;
	for(i=0;i<MAXSIZE-1;i++)
        space[i].cur=i+1;
    space[MAXSIZE-1].cur=0;
    return OK;
}
```

### 2.2静态链表插入元素--获得空闲分量的下标

```c
Status Malloc_SLL(StaticLinkList space)
{
    int i=space[0].cur;
    if(space[0].cur)//静态链表还有备用链表
        space[0].cur=space[i].cur;
    //把他的下一个分量作为备用
    return i;
}
```

游标	5	2	3	4	0	6	7	...	1

数据		  A	C	D   E		    	 ...

下标	0	1	2	3	4	5	6	...	999

### 2.3静态链表插入元素

```c
Status InsertList(StaticLinkList L,int i,EleType e)
{
    int j,k,l;
    
    k=MAXSIZE-1;
    if(i<1||i>ListLength(L)+1)
    {
        return ERROR;
    }   
    j=Malloc_SLL(L);//空闲分量的下标
    if(j)//静态链表还有备用链表
    {
        L[j].data=e;
        for(l=1;l<=i-1;l++)
        {
            k=L[k].cur;
        }
        L[j].cur=L[k].cur;
        L[k].cur=j;
            
        return OK;        
    }
    return ERROR;
}
```

#### 2.4静态链表删除元素(最后一个元素)

```c
Status DeleteList(StaticLinkList L,int i)
{
    int j,k;
    if(i<1||i>ListLength(L))
    {
        return ERROR;
    }
    k=MAXSIZE-1;
    
    for(j=1;j<=i-1;j++)
    {
        k=L[k].cur;
    }
    
    j=L[k].cur;
    L[k].cur=L[j].cur;
    Free_SLL(L,j);
    return OK;
}

void Free_SLL(StaticLinkList space,int i)
{
    space[i].cur=space[0].cur;
    space[0].cur=i;
}

int ListLength(StaticLinkList L)
{
    int j=0;
    int k=L[MAXSIZE-1].cur;
    while(k)
    {
        k=L[k].cur;
        j++;
    }
    rerutn j;
}
```

### 三、循环链表

循环链表不一定有头结点

#### 3.1循环链表定义

```c
typedef struct CLinkList
{
    int data;
    struct CLinkList* node;
}node;
```

#### 3.2循环链表初始化

```c
void ds_init(node **pNode)
{
    int item;
    node *temp;
    node *target;
    
    ptintf("请输入节点的值");
    
    while(1)
    {
        scanf("%d",&item);
        fflush(stdin);//刷新缓存
        if(item==0)
            return;
        if((*pNode)==NULL)
        {
            *pNode=(node*)malloc(sizeof(struct cLinkList));
            if(!(*pNode))
            	exit(0);
            *pNode->data=item;
            *pNode->next=*pNode;//使之循环
        }
        else
        {
            for(target=*pNode;target->next!=*pNode;target=target->next)
                ;
            temp=(node*)malloc(sizeof(struct cLinkList));
            if(!temp)
            	exit(0);
            temp->data=item;
            temp->next=*pNode;
            target->next=temp;
        }
    }
}
```

#### 3.3循环链表插入

```c
void ds_insert(node **pNode,int i)
{
    int item;
    node *temp;
    node *target;
    node *p;
    
    ptintf("请输入节点的值");
    scanf("%d",&item);
    
    if(i==1)//插入第一个节点
    {
        *temp=(node*)malloc(sizeof(struct cLinkList));
        if(!temp)
        exit(0);
        
        temp->data=item;
        for(target=*pNode;target->next!=*pNode;target=target->next)
                ;
        target->next=temp;
        temp->next=*pNode;
        *pNode=temp;////////////////注意
    }
    else
    {
        target=*pNode;
        for(int j=1;j<(i-1);j++)
        {
            target=target->next;
        }
        
        *temp=(node*)malloc(sizeof(struct cLinkList));//开辟内存空间了才能存储数据
        if(!temp)
        	exit(0);
        temp->data=item;
        p=target->next;
        
        target->next=temp;
        temp->next=p;
    }
}
```

#### 3.4循环链表删除

```c
void ds_insert(node **pNode,int i)
{
    node *temp;
    node *target;
    node *p;
    
    if(i==1)//删除第一个节点
    {       
        for(target=*pNode;target->next!=*pNode;target=target->next)
                ;
        temp=*pNode;//做释放用的
        *pNode=(*pNode)->next;
        target->next=*pNode;
        free(temp);
    }
    else
    {
        target=*pNode;
        for(int j=1;j<(i-1);j++)
        {
            target=target->next;
        }        
        temp=target->next;//做释放用的
        target->next=temp->next;
        free(temp);
    }
}
```

#### 3.5循环链表查找

```c
int ds_search(node *pNode,int elem)
{
    node *target;
    int i=1;
    for(target=*pNode;target->data!=elem&&target->next!=*pNode;target=target->next)
    {
        target=target->next;
    }
    if(target->data!=data)
    	return 0;
    else
        return i;
}
```

3.6魔术师问题

```c
//初始化
LinkList CreateLinkList()
{
    LinkList head=NULL;
    LinkList r,s;
    int i;
    
    r=head;
    for(i=1;i<=CardNumber;i++)
    {
        s=(LinkList)malloc(sizeof(sqList));
        s->data=0;
        if(head==NULL)
            head=s;
        else
            r->next=s;
        r=s;
    }
    r->next=head;
    return head;
}

//发牌顺序计算
void Magician(LinkList head)
{
    LinkList p;
    int j;
    int Countnumber=2;
    
    p=head;
    p->data=1;//第一张牌放一
    while(1)
    {
        for(j=0;j<Countnumber;j++)
        {
            p=p->next;
            if(p->data!=0)//有牌下一个位置
            {
                //p=p->next;
                j--;
            }
        }
        if(p->data==0)
        {
            p->data=Countnumber;
            Countnumber++; 
            if(Countnumber==14)
                break;
        }
    }
}

//销毁
void DestroyList(LinkList* list)
{
    
}

int main()
{
    LinkList p;
    p=CreateLinkList();
    Magician(p);
    printf("顺序依次是");
    for(int i=0;i<Countnumber;i++)
    {
        printf("黑桃%d",p->data);
        p=p->next;
    }
    DestroyList(&p);
    return 0;	
}
```

### 四、双向链表

```c
typedef struct DualNode
{
    ElemType data;
    struct DualNode *prior;
    struct DualNode *next;    
}DualNode,* DuLinkList;
```

#### 4.1双向链表的插入操作

[  |  |  ]				[  |  |  ]p

  			[  |  |  ]s

```c
s->next=p;
s->prior=p->prior;
p->prior->next=s;
p->prior=s;
```

#### 4.2双向链表的删除操作

[  |  |  ]	[  |  |  ]p   [  |  |  ]

```c
p->prior->next=p->next;
p->next->prior=p->prior;
free(p);
```

#### 4.3双向循环链表实践

按要求输出26个英文字母

```c
#include "malloc.h"
#include<stdio.h>
#include <iostream>
using namespace std;

#define OK 1;
#define ERROR 0;
typedef char ElemType;
typedef int status;
//节点
typedef struct DualNode
{
    ElemType data;
    struct DualNode* prior;
    struct DualNode* next;
}DualNode,* DuLinkList;

//建立链表
status InitDuLinkList(DuLinkList * L)//尾插法
{
    DuLinkList p,q;

    *L=(DuLinkList)malloc(sizeof(DualNode));//头节点没有数据
    if (!(*L))
        return ERROR;
    (*L)->next = NULL;
    (*L)->prior = NULL;
    p = (*L);

    for (int i = 0; i < 26; i++)
    {
        q=(DuLinkList)malloc(sizeof(DualNode));
        if (!q)
            return ERROR;
        q->data = 'A' +i;
        q->prior = p;
        q->next = p->next;
        p->next = q;

        p = q;
    }
    p->next = (*L)->next;//不要忘
    (*L)->next->prior = p;
    return OK;
}
void Ceasar(DuLinkList* L,int n)//(*L)初始节点位置
{
    if (n > 0)
    {
        do
        {
            (*L) = (*L)->next;
        } while (n--);
    }
    if (n < 0)
    {
        (*L) = (*L)->next;//有头结点
        do
        {
            (*L) = (*L)->prior;
        } while (++n);
    }
}
int main()
{
    int n;
    printf("请输入一个整数\n");
    cin >> n;

    DuLinkList p;
    InitDuLinkList(&p);
    Ceasar(&p, n);
    for(int i=0;i<26;i++)
    {
        printf("%c ", p->data);
        p = p->next;
    }   
    return 0;
}
```

### 五、栈

#### 5.1栈的顺序存储结构

```c
typedef struct
{
    ElemType *base;
    ElemType *top;
    int stackSize;//栈的最大容量，占据内存空间的大小
}sqStack;
```

#### 5.2创建一个栈

```c
#define STACK_INIT_SIZE 100
initSttack(sqStack *s)
{
    s->base=(ElemType *)malloc(STACK_INIT_SIZE*sizeof(ElemType));////??sqStack
    if(!s->base)
        exit(0);
    s->stop=s->base;//最开始，栈顶就是栈底
    s->stackSize=STACK_INIT_SIZE;
}
```

#### 5.3入栈操作

```c
#define STACKINCREMENT 10

Push(sqStack *s,ElemType e)
{
    //如果栈满，追加空间
    if(s->top-s->base>=s->stackSize)
    {
        s->base=(ElemType*)realloc(s->base,(s->stackSize+STACKINCREMENT)
                                   *sizeof(ElemType));
        if(!s->base)
            exit(0);
        s->top=s->base+s->stackSize;
        s->stackSize=s->stackSize+STACKINCREMENT;        
    }
    *(s->top)=e;
    s->top++;
}
```

#### 5.4出栈操作

```c
Pop(sqStack *s,ElemType *e)
{
    if(s->top==s->base)//空栈
        return;
    *e=*--(s->top);
}
```

#### 5.5销毁一个栈

```c
DestroyStack(sqStack *s)
{
    int len,i;
    len=s->stackSize;
    for(i=0;i<len;i++)
    {
        free(s->base);
        s->base++;
    }
    s->base=s->top=NULL
    s->stackSize=0;
}
```

5.6栈的当前容量

```c
int StackLen(sqStack s)
{
    return (s.top-s.base);//栈的最大容量，占据内存空间的大小
}
```

